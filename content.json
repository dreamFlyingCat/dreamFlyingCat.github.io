[{"title":"mongoose v5.0.12 中文API - Validation","date":"2018-04-09T04:17:33.740Z","path":"2018/04/09/mongoose-Validation/","text":"官方原版：http://mongoosejs.com引用请注明出处和转载请注明出处 Validation在我们使用确定的validation语法前，请先记住下面的规则： Validation是在SchemaType中定义的额； Validation是中间件的内部组件，schema默认使用pre(&#39;save&#39;)钩子函数注册validation； 你可以使用doc.validate(callback)或者doc.validateSync()进行手动的validation。 除了required验证器，validate不会在undefined值上运行； validate是异步递归执行的，如果顶层document调用Model#save，sub-document的验证也会执行。一旦发生错误，Model#save的回调函数会收它。 validation支持自定义。 var schema = new Schema({ name: { type: String, required: true } }); var Cat = db.model(&apos;Cat&apos;, schema); // This cat has no name :( var cat = new Cat(); cat.save(function(error) { assert.equal(error.errors[&apos;name&apos;].message, &apos;Path `name` is required.&apos;); error = cat.validateSync(); assert.equal(error.errors[&apos;name&apos;].message, &apos;Path `name` is required.&apos;); }); 内置验证器Mongoose提供了一些内置的验证器。 所有的SchemaType都有required验证器，其使用checkRequired()函数判断值是否符合要求。 Numbers有专属的min和max验证器； String有专属enum、match、maxlength、minlength验证器。 上面的每一个验证器链接提供关于如何使用它们和定制错误信息。 var breakfastSchema = new Schema({ eggs: { type: Number, min: [6, &apos;Too few eggs&apos;], max: 12 }, bacon: { type: Number, required: [true, &apos;Why no bacon?&apos;] }, drink: { type: String, enum: [&apos;Coffee&apos;, &apos;Tea&apos;], required: function() { return this.bacon &gt; 3; } } }); var Breakfast = db.model(&apos;Breakfast&apos;, breakfastSchema); var badBreakfast = new Breakfast({ eggs: 2, bacon: 0, drink: &apos;Milk&apos; }); var error = badBreakfast.validateSync(); assert.equal(error.errors[&apos;eggs&apos;].message, &apos;Too few eggs&apos;); assert.ok(!error.errors[&apos;bacon&apos;]); assert.equal(error.errors[&apos;drink&apos;].message, &apos;`Milk` is not a valid enum value for path `drink`.&apos;); badBreakfast.bacon = 5; badBreakfast.drink = null; error = badBreakfast.validateSync(); assert.equal(error.errors[&apos;drink&apos;].message, &apos;Path `drink` is required.&apos;); badBreakfast.bacon = null; error = badBreakfast.validateSync(); assert.equal(error.errors[&apos;bacon&apos;].message, &apos;Why no bacon?&apos;); unique选项不是一个验证器unique选项不是一个验证器，它用于快速建立MongoDB的unique indexes。更多信息查看FAQ。 var uniqueUsernameSchema = new Schema({ username: { type: String, unique: true } }); var U1 = db.model(&apos;U1&apos;, uniqueUsernameSchema); var U2 = db.model(&apos;U2&apos;, uniqueUsernameSchema); var dup = [{ username: &apos;Val&apos; }, { username: &apos;Val&apos; }]; U1.create(dup, function(error) { // Race condition! This may save successfully, depending on whether // MongoDB built the index before writing the 2 docs. }); // Need to wait for the index to finish building before saving, // otherwise unique constraints may be violated. U2.once(&apos;index&apos;, function(error) { assert.ifError(error); U2.create(dup, function(error) { // Will error, but will *not* be a mongoose validation error, it will be // a duplicate key error. assert.ok(error); assert.ok(!error.errors); assert.ok(error.message.indexOf(&apos;duplicate key error&apos;) !== -1); }); }); // There&apos;s also a promise-based equivalent to the event emitter API. // The `init()` function is idempotent and returns a promise that // will resolve once indexes are done building; U2.init().then(function() { U2.create(dup, function(error) { // Will error, but will *not* be a mongoose validation error, it will be // a duplicate key error. assert.ok(error); assert.ok(!error.errors); assert.ok(error.message.indexOf(&apos;duplicate key error&apos;) !== -1); }); }); 自定义验证器如果内置的验证器满足不了你的需求，你可以使用自定义验证器。 通过传递一个validation函数实现自定义，具体细节查看SchemaType#validate()章节API文档 var userSchema = new Schema({ phone: { type: String, validate: { validator: function(v) { return /\\d{3}-\\d{3}-\\d{4}/.test(v); }, message: &apos;{VALUE} is not a valid phone number!&apos; }, required: [true, &apos;User phone number required&apos;] } }); var User = db.model(&apos;user&apos;, userSchema); var user = new User(); var error; user.phone = &apos;555.0123&apos;; error = user.validateSync(); assert.equal(error.errors[&apos;phone&apos;].message, &apos;555.0123 is not a valid phone number!&apos;); user.phone = &apos;&apos;; error = user.validateSync(); assert.equal(error.errors[&apos;phone&apos;].message, &apos;User phone number required&apos;); user.phone = &apos;201-555-0123&apos;; // Validation succeeds! Phone number is defined // and fits `DDD-DDD-DDDD` error = user.validateSync(); assert.equal(error, null); 自定义异步验证器我们也可以自定义异步验证器。如果验证器函数返回一个promise实例（像一个async函数）,mongoose会等待promise状态确定。如果你更喜欢callbacks形式，设置isAsync选项并且给验证器函数传入callback作为第二个参数。 var userSchema = new Schema({ name: { type: String, // You can also make a validator async by returning a promise. If you // return a promise, do **not** specify the `isAsync` option. validate: function(v) { return new Promise(function(resolve, reject) { setTimeout(function() { resolve(false); }, 5); }); } }, phone: { type: String, validate: { isAsync: true, validator: function(v, cb) { setTimeout(function() { var phoneRegex = /\\d{3}-\\d{3}-\\d{4}/; var msg = v + &apos; is not a valid phone number!&apos;; // First argument is a boolean, whether validator succeeded // 2nd argument is an optional error message override cb(phoneRegex.test(v), msg); }, 5); }, // Default error message, overridden by 2nd argument to `cb()` above message: &apos;Default error message&apos; }, required: [true, &apos;User phone number required&apos;] } }); var User = db.model(&apos;User&apos;, userSchema); var user = new User(); var error; user.phone = &apos;555.0123&apos;; user.name = &apos;test&apos;; user.validate(function(error) { assert.ok(error); assert.equal(error.errors[&apos;phone&apos;].message, &apos;555.0123 is not a valid phone number!&apos;); assert.equal(error.errors[&apos;name&apos;].message, &apos;Validator failed for path `name` with value `test`&apos;); }); 错误验证如果验证失败会返回错误包含了一个错误对象，值为ValidatorError对象。ValidatorError对象有kind、path、value和message等属性。验证器也可能有reason属性，如果执行验证器时发生了错误，reason属性包含抛出的错误。 var toySchema = new Schema({ color: String, name: String }); var validator = function(value) { return /red|white|gold/i.test(value); }; toySchema.path(&apos;color&apos;).validate(validator, &apos;Color `{VALUE}` not valid&apos;, &apos;Invalid color&apos;); toySchema.path(&apos;name&apos;).validate(function(v) { if (v !== &apos;Turbo Man&apos;) { throw new Error(&apos;Need to get a Turbo Man for Christmas&apos;); } return true; }, &apos;Name `{VALUE}` is not valid&apos;); var Toy = db.model(&apos;Toy&apos;, toySchema); var toy = new Toy({ color: &apos;Green&apos;, name: &apos;Power Ranger&apos; }); toy.save(function (err) { // `err` is a ValidationError object // `err.errors.color` is a ValidatorError object assert.equal(err.errors.color.message, &apos;Color `Green` not valid&apos;); assert.equal(err.errors.color.kind, &apos;Invalid color&apos;); assert.equal(err.errors.color.path, &apos;color&apos;); assert.equal(err.errors.color.value, &apos;Green&apos;); // This is new in mongoose 5. If your validator throws an exception, // mongoose will use that message. If your validator returns `false`, // mongoose will use the &apos;Name `Power Ranger` is not valid&apos; message. assert.equal(err.errors.name.message, &apos;Need to get a Turbo Man for Christmas&apos;); assert.equal(err.errors.name.value, &apos;Power Ranger&apos;); // If your validator threw an error, the `reason` property will contain // the original error thrown, including the original stack trace. assert.equal(err.errors.name.reason.message, &apos;Need to get a Turbo Man for Christmas&apos;); assert.equal(err.name, &apos;ValidationError&apos;); }); 对嵌套对象使用Required验证器对类型嵌套对象的属性进行验证是比较棘手的，因为嵌套对象不完全成熟的路径。 var personSchema = new Schema({ name: { first: String, last: String } }); assert.throws(function() { // This throws an error, because &apos;name&apos; isn&apos;t a full fledged path personSchema.path(&apos;name&apos;).required(true); }, /Cannot.*&apos;required&apos;/); // To make a nested object required, use a single nested schema var nameSchema = new Schema({ first: String, last: String }); personSchema = new Schema({ name: { type: nameSchema, required: true } }); var Person = db.model(&apos;Person&apos;, personSchema); var person = new Person(); var error = person.validateSync(); assert.ok(error.errors[&apos;name&apos;]); 更新验证器上面实例中，你学习了document的验证。Mongoose也支持执行update()或findOneAndUpdate()时的更新验证。更新验证默认关闭。设置runValidators选项，开启update()或者findOneAndUpdate()的更新验证。请注意，更新验证之所以默认关闭，因为会有一些警告信息。 var toySchema = new Schema({ color: String, name: String }); var Toy = db.model(&apos;Toys&apos;, toySchema); Toy.schema.path(&apos;color&apos;).validate(function (value) { return /blue|green|white|red|orange|periwinkle/i.test(value); }, &apos;Invalid color&apos;); var opts = { runValidators: true }; Toy.update({}, { color: &apos;bacon&apos; }, opts, function (err) { assert.equal(err.errors.color.message, &apos;Invalid color&apos;); }); 更新验证器和this更新验证器和document validator会有些不同。下面示例中，color path的验证函数中this指向正在被验证的document。然而执行更新验证时，document可能不在服务器内存中更新，所以默认this未定义。 var toySchema = new Schema({ color: String, name: String }); toySchema.path(&apos;color&apos;).validate(function(value) { // When running in `validate()` or `validateSync()`, the // validator can access the document using `this`. // Does **not** work with update validators. if (this.name.toLowerCase().indexOf(&apos;red&apos;) !== -1) { return value !== &apos;red&apos;; } return true; }); var Toy = db.model(&apos;ActionFigure&apos;, toySchema); var toy = new Toy({ color: &apos;red&apos;, name: &apos;Red Power Ranger&apos; }); var error = toy.validateSync(); assert.ok(error.errors[&apos;color&apos;]); var update = { color: &apos;red&apos;, name: &apos;Red Power Ranger&apos; }; var opts = { runValidators: true }; Toy.update({}, update, opts, function(error) { // The update validator throws an error: // &quot;TypeError: Cannot read property &apos;toLowerCase&apos; of undefined&quot;, // because `this` is **not** the document being updated when using // update validators assert.ok(error); }); context选项设置context选项，使this值在更新验证时指向隐藏的query。 var toySchema = new Schema({ color: String, name: String }); toySchema.path(&apos;color&apos;).validate(function(value) { // When running in `validate()` or `validateSync()`, the // validator can access the document using `this`. // Does **not** work with update validators. if (this.name.toLowerCase().indexOf(&apos;red&apos;) !== -1) { return value !== &apos;red&apos;; } return true; }); var Toy = db.model(&apos;ActionFigure&apos;, toySchema); var toy = new Toy({ color: &apos;red&apos;, name: &apos;Red Power Ranger&apos; }); var error = toy.validateSync(); assert.ok(error.errors[&apos;color&apos;]); var update = { color: &apos;red&apos;, name: &apos;Red Power Ranger&apos; }; var opts = { runValidators: true }; Toy.update({}, update, opts, function(error) { // The update validator throws an error: // &quot;TypeError: Cannot read property &apos;toLowerCase&apos; of undefined&quot;, // because `this` is **not** the document being updated when using // update validators assert.ok(error); }); 指定需要更新验证器的路径请注意一个非常重要的细节，只有在执行以下更新操作时，更新验证器才会运行： $set $unset $push(&gt;=4.8.0) $addToSet(&gt;=4.8.0) $pull(&gt;=4.12.0) $pullAll(&gt;=4.12.0) 下例中的更新不会检查number值，所以更新可以执行成功，因为$inc操作不会执行更新验证器。 $push、$addToSet、$pull和$pullAll等操作不会验证数组本身，只会单独的验证数组中的元素。 var testSchema = new Schema({ number: { type: Number, max: 0 }, arr: [{ message: { type: String, maxlength: 10 } }] }); // Update validators won&apos;t check this, so you can still `$push` 2 elements // onto the array, so long as they don&apos;t have a `message` that&apos;s too long. testSchema.path(&apos;arr&apos;).validate(function(v) { return v.length &lt; 2; }); var Test = db.model(&apos;Test&apos;, testSchema); var update = { $inc: { number: 1 } }; var opts = { runValidators: true }; Test.update({}, update, opts, function(error) { // There will never be a validation error here update = { $push: [{ message: &apos;hello&apos; }, { message: &apos;world&apos; }] }; Test.update({}, update, opts, function(error) { // This will never error either even though the array will have at // least 2 elements. }); }); $push和$addToSet的更新验证执行$push和$addToSet操作时，也会执行更新验证器。 var testSchema = new Schema({ numbers: [{ type: Number, max: 0 }], docs: [{ name: { type: String, required: true } }] }); var Test = db.model(&apos;TestPush&apos;, testSchema); var update = { $push: { numbers: 1, docs: { name: null } } }; var opts = { runValidators: true }; Test.update({}, update, opts, function(error) { assert.ok(error.errors[&apos;numbers&apos;]); assert.ok(error.errors[&apos;docs&apos;]); }); 下一章 —— Middleware","tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://dreamflyingcat.github.io/tags/mongoose/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://dreamflyingcat.github.io/tags/mongoDB/"},{"name":"node.js","slug":"node-js","permalink":"https://dreamflyingcat.github.io/tags/node-js/"}]},{"title":"mongoose v5.0.12 中文API - Subdocuments","date":"2018-04-09T04:16:51.276Z","path":"2018/04/09/mongoose-Subdocuments/","text":"官方原版：http://mongoosejs.com引用请注明出处和转载请注明出处 Sub DocsSubDocuments是嵌套在其他documents中的documents，这意味着你可以在Schemas中嵌套Schemas。Mongoose支持两种不同形式的subdocuments：subdocuments数组和单独嵌套的subdocuments（mongoose版本大于等于4.2.0）。 var childSchema = new Schema({ name: &apos;string&apos; }); var parentSchema = new Schema({ // Array of subdocuments children: [childSchema], // Single nested subdocuments. Caveat: single nested subdocs only work // in mongoose &gt;= 4.2.0 child: childSchema }); sub-document享有所有与普通document相同的特征。嵌套的Schemas也可以有[middleware][http://mongoosejs.com/docs/middleware.html]和自定义的[validation][]，逻辑和使用与顶层schemas相同。subdocument最大的不同是不能单独保存，当它们的顶层父document保存时它们才被保存。 var Parent = mongoose.model(&apos;Parent&apos;, parentSchema); var parent = new Parent({ children: [{ name: &apos;Matt&apos; }, { name: &apos;Sarah&apos; }] }) parent.children[0].name = &apos;Matthew&apos;; // `parent.children[0].save()` is a no-op, it triggers middleware but // does **not** actually save the subdocument. You need to save the parent // doc. parent.save(callback); Subdocuments也有类似于顶层documents的save和validate中间件。调用save()保存父级document会触发所有的subdocuments的save()和validate()。 childSchema.pre(&apos;save&apos;, function (next) { if (&apos;invalid&apos; == this.name) { return next(new Error(&apos;#sadpanda&apos;)); } next(); }); var parent = new Parent({ children: [{ name: &apos;invalid&apos; }] }); parent.save(function (err) { console.log(err.message) // #sadpanda }); Subdocuments的pre(&#39;save&#39;)和pre(&#39;validate&#39;)中间件会在顶层ducument的pre(&#39;save&#39;)之前和pre(&#39;validate&#39;)之后执行。这是因为validating是一种内置的中间件，会在save()之前执行。 // Below code will print out 1-4 in order var childSchema = new mongoose.Schema({ name: &apos;string&apos; }); childSchema.pre(&apos;validate&apos;, function(next) { console.log(&apos;2&apos;); next(); }); childSchema.pre(&apos;save&apos;, function(next) { console.log(&apos;3&apos;); next(); }); var parentSchema = new mongoose.Schema({ child: childSchema, }); parentSchema.pre(&apos;validate&apos;, function(next) { console.log(&apos;1&apos;); next(); }); parentSchema.pre(&apos;save&apos;, function(next) { console.log(&apos;4&apos;); next(); }); 查找sub-document每个subdocument都有一个_id,DocumentArrays有特殊的 id 方法来通过_id来查找document。。 向数组中追加sub-docsmongoose数组方法如push、unshift、addToSet等将参数显式转换成恰当的类型。 var Parent = mongoose.model(&apos;Parent&apos;); var parent = new Parent; // create a comment parent.children.push({ name: &apos;Liesl&apos; }); var subdoc = parent.children[0]; console.log(subdoc) // { _id: &apos;501d86090d371bab2c0341c5&apos;, name: &apos;Liesl&apos; } subdoc.isNew; // true parent.save(function (err) { if (err) return handleError(err) console.log(&apos;Success!&apos;); }); 也可以通过MongooseArrays的[create][]方法直接创建sub-docs，无需添加的数组中。 var newdoc = parent.children.create({ name: &apos;Aaron&apos; }); 删除subdocs移除subdocuments可以使用remove方法，对于subdocument数组来说，该方法等同于使用.pull()，在单独嵌套的subdocument使用该方法，相当于设置subdocument为null。 // Equivalent to `parent.children.pull(_id)` parent.children.id(_id).remove(); // Equivalent to `parent.child = null` parent.child.remove(); parent.save(function (err) { if (err) return handleError(err); console.log(&apos;the subdocs were removed&apos;); }); 数组的交替声明语法如果你在Schema中声明一个对象数组的属性，mongoose会自动的将对象字面量转换成Schema（如果你不需要访问的子文档schena的实例，你也可以通过简单传递一个对象字面量声明子文档）。 var parentSchema = new Schema({ children: [{ name: &apos;string&apos; }] }); // Equivalent var parentSchema = new Schema({ children: [new Schema({ name: &apos;string&apos; })] }); 下一章 —— Queries","tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://dreamflyingcat.github.io/tags/mongoose/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://dreamflyingcat.github.io/tags/mongoDB/"},{"name":"node.js","slug":"node-js","permalink":"https://dreamflyingcat.github.io/tags/node-js/"}]},{"title":"mongoose v5.0.12 中文API - SchemaTypes","date":"2018-04-09T04:16:19.399Z","path":"2018/04/09/mongoose-SchemaTypes/","text":"官方原版：http://mongoosejs.com引用请注明出处和转载请注明出处 SchemaTypesSchemaTypes定义路径（path）的dufaults、validation、getters、setters及查询时默认选择的field等属性，还有Strings和Numbers的其他的一些特征。 下面是mongoose中可用的SchemaTypes： String Number Date Buffer Boolean Mixed Objectid Array Decimal128 例子var schema = new Schema({ name: String, binary: Buffer, living: Boolean, updated: { type: Date, default: Date.now }, age: { type: Number, min: 18, max: 65 }, mixed: Schema.Types.Mixed, _someId: Schema.Types.ObjectId, decimal: Schema.Types.Decimal128, array: [], ofString: [String], ofNumber: [Number], ofDates: [Date], ofBuffer: [Buffer], ofBoolean: [Boolean], ofMixed: [Schema.Types.Mixed], ofObjectId: [Schema.Types.ObjectId], ofArrays: [[]], ofArrayOfNumbers: [[Number]], nested: { stuff: { type: String, lowercase: true, trim: true } } }) // example use var Thing = mongoose.model(&apos;Thing&apos;, schema); var m = new Thing; m.name = &apos;Statue of Liberty&apos;; m.age = 125; m.updated = new Date; m.binary = new Buffer(0); m.living = false; m.mixed = { any: { thing: &apos;i want&apos; } }; m.markModified(&apos;mixed&apos;); m._someId = new mongoose.Types.ObjectId; m.array.push(1); m.ofString.push(&quot;strings!&quot;); m.ofNumber.unshift(1,2,3,4); m.ofDates.addToSet(new Date); m.ofBuffer.pop(); m.ofMixed = [1, [], &apos;three&apos;, { four: 5 }]; m.nested.stuff = &apos;good&apos;; m.save(callback); SchemaType选项设置你可以直接使用可用的type类型来声明一个schema type或者使用一个包含type字段的对象 var schema1 = new Schema({ test: String // `test` is a path of type String }); var schema2 = new Schema({ test: { type: String } // `test` is a path of type string }); 除了type之外你还可以给path指定其他的一些属性，例如，你想要在保存字符串之前将它转化为小写。 var schema2 = new Schema({ test: { type: String, lowercase: true // Always convert `test` to lowercase } }); 只有string类型的字段可以设置lowercase属性。有些选项适用于所有的schema类型，有些只适用于指定的schema类型。 适用于所有schema类型的选项 required：boolean或者function，如果值为true时可以为字段添加一个必须验证器； default：任意值或者function，用于给path设置默认值，如果值是一个函数，其返回值作为path的默认值； select：boolean，指明查询时选择的字段； validate：function，为字段添加验证器函数； get：function，使用Object.defineProperty为字段自定义getter函数; set：function，使用Object.defineProperty为字段自定义setter函数; alias：stirng，mongoose&gt;=4.10.0才可以使用，为给定的字段设置一个别名，通过sets/gets设置或获取值； var numberSchema = new Schema({ integerOnly: { type: Number, get: v =&gt; Math.round(v), set: v =&gt; Math.round(v), alias: &apos;i&apos; } }); var Number = mongoose.model(‘Number’, numberSchema); var doc = new Number(); doc.integerOnly = 2.001; doc.integerOnly; // 2 doc.i; // 2 doc.i = 3.001; doc.integerOnly; // 3 doc.i; // 3 indexes可以通过设置schema类型的选项来定义mongoDB的索引； index：boolean，是否在该字段上建立索引（建立索引加快搜索速度，拖慢更新速度，因为更新数据时索引也要更新）； unique：boolean，是否在该字段上定义唯一的索引； sparse：boolean，是否在该字段上建立稀疏索引（稀疏索引会跳过键值不存在的文档）。 var schema2 = new Schema({ test: { type: String, index: true, unique: true // Unique index. If you specify unique: true // specifying index: true is optional if you do unique: true } }); String lowercase：boolean，是否总是调用toLowerCase()函数将字段值转为小写； uppercase：boolean，是否总是调用toUpperCase()函数将字段值转为大写； trim：boolean，是否总是调用trim()去掉字段值中的空格； match：RegExp，创建一个验证器检查字段值是否符合给出的正则表达式； enum：Array，一个验证器用于检查字段值是否在给定的数组中。 Number min：Number，创建一个验证器用于检查字段值是否大于或等于给定的最小值； max：Number，创建一个验证器用于检查字段值是否小于或等于给定的最大值。 Date min：Date（日期需大于等于min值）； max：Date（日期需小于等于max值）。 使用注意事项Date对象内置的方法并没有和Mongoose关联起来，这意味着如果你调用Date的方法修改Document的Date类型值并保存并不会起作用，因为mongoose意识不到Date值变了，所以doc.save()无法保存修改。如果你必须使用内置的方法修改Date类型的值，保存前请调用doc.marckModified(&#39;pathToYourDate&#39;)通知mongoose此更改。 var Assignment = mongoose.model(&apos;Assignment&apos;, { dueDate: Date }); Assignment.findOne(function (err, doc) { doc.dueDate.setMonth(3); doc.save(callback); // THIS DOES NOT SAVE YOUR CHANGE doc.markModified(&apos;dueDate&apos;); doc.save(callback); // works }) MixedMixed类型接受任意类型的值，该类型虽然很灵活但是却难以维护，在schema中可以定义Mixed类型的字段。下面的几种方法是等价的，都可以声明字段为Mixed类型。 var Any = new Schema({ any: {} }); var Any = new Schema({ any: Object }); var Any = new Schema({ any: Schema.Types.Mixed }); Mixed属于chema-less类型的一种，你可以改变值为任意你想要的类型，但是mongoose失去了自动检测值的修改并保存修改的能力。如果你修改了Mixed类型的值，需要调用doc.markModified(path)方法通知mongoose该修改。 person.anything = { x: [3, 4, { y: &quot;changed&quot; }] }; person.markModified(&apos;anything&apos;); person.save(); // anything will now get saved ObjectIds声明字段时，设置类型为Schema.Types.ObjectId，指定值为ObjectId的一种类型。 var mongoose = require(&apos;mongoose&apos;); var ObjectId = mongoose.Schema.Types.ObjectId; var Car = new Schema({ driver: ObjectId }); // or just Schema.ObjectId for backwards compatibility with v2 Arrays设置字段值类型为SchemaTypes或者Sub-Documents类型的数组。 var ToySchema = new Schema({ name: String }); var ToyBox = new Schema({ toys: [ToySchema], buffers: [Buffer], string: [String], numbers: [Number] // ... etc }); 注意：如果数组为空等价于Mixed类型，下列方法均创建元素为Mixed类型的数组。 var Empty1 = new Schema({ any: [] }); var Empty2 = new Schema({ any: Array }); var Empty3 = new Schema({ any: [Schema.Types.Mixed] }); var Empty4 = new Schema({ any: [{}] }); 设置默认值为undefined重写默认情况 var ToySchema = new Schema({ toys: { type: [ToySchema], default: undefined } }); 创建自定义的类型mongoose支持plugins扩展自定义schemaTypes，查看plugins网站查看可用的类型，例如mongoose-long、mongoose-int32还有其他的类型。 schema.path()函数schema.path()函数返回指定path的实例化的schema类型。 var sampleSchema = new Schema({ name: { type: String, required: true } }); console.log(sampleSchema.path(&apos;name&apos;)); // Output looks like: /** * SchemaString { * enumValues: [], * regExp: null, * path: &apos;name&apos;, * instance: &apos;String&apos;, * validators: ... */ 可以使用该函数查看path的schema类型，包括验证器和字段的类型。 下一章 —— Connections","tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://dreamflyingcat.github.io/tags/mongoose/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://dreamflyingcat.github.io/tags/mongoDB/"},{"name":"node.js","slug":"node-js","permalink":"https://dreamflyingcat.github.io/tags/node-js/"}]},{"title":"mongoose v5.0.12 中文API - Queries","date":"2018-04-09T04:15:10.054Z","path":"2018/04/09/mongoose-Queries/","text":"官方原版：http://mongoosejs.com引用请注明出处和转载请注明出处 Queriesmodels提供了多个静态方法，用于检索Documents。任何涉及指定查询条件的models方法都能通过两个方法执行。根据是否传入回调函数，有以下两种情况： 传入callback，操作将立即执行，结果传给回调函数； 不传callback，返回一个查询实例，它将提供一个特殊的查询生成接口。对于第二种情况，Query实例对象有.then()方法，所以可以用作promise实例对象。 执行查询时候传入callback回调函数，查询结果会以JSON格式返回。JSON文档的语法与MongoDB shell相同。 var Person = mongoose.model(&apos;Person&apos;, yourSchema); // find each person with a last name matching &apos;Ghost&apos;, selecting the `name` and `occupation` fields Person.findOne({ &apos;name.last&apos;: &apos;Ghost&apos; }, &apos;name occupation&apos;, function (err, person) { if (err) return handleError(err); // Prints &quot;Space Ghost is a talk show host&quot;. console.log(&apos;%s %s is a %s.&apos;, person.name.first, person.name.last,person.occupation); }); 上例中，查询会被立即执行并将结果传入callback。Mongoose中所有的callbacks都遵循模式：callback(error, result)。如果查询时出错，error参数会包含一个错误对象且result为null。如果查询成功，error参数为null，result为查询结果。 Mongoose中任何情况下传入回调函数，都遵循callback(error, results)模式。查询结果取决于执行的操作：findOne()为可能为空的单document，find()为多个document，count()为document的个数，update()为受影响的document的数量。Model的API文档详细介绍了回调函数的可能结果。 现在看看在没有回调的情况下会发生什么：： // find each person with a last name matching &apos;Ghost&apos; var query = Person.findOne({ &apos;name.last&apos;: &apos;Ghost&apos; }); // selecting the `name` and `occupation` fields query.select(&apos;name occupation&apos;); // execute the query at a later time query.exec(function (err, person) { if (err) return handleError(err); // Prints &quot;Space Ghost is a talk show host.&quot; console.log(&apos;%s %s is a %s.&apos;, person.name.first, person.name.last,person.occupation); }); 上面代码中，query变量是Query的一种类型。Query允许你建立链式的查询语法，而不是指定JSON对象。下面两个例子是等价的： // With a JSON doc Person. find({ occupation: /host/, &apos;name.last&apos;: &apos;Ghost&apos;, age: { $gt: 17, $lt: 66 }, likes: { $in: [&apos;vaporizing&apos;, &apos;talking&apos;] } }). limit(10). sort({ occupation: -1 }). select({ name: 1, occupation: 1 }). exec(callback); // Using query builder Person. find({ occupation: /host/ }). where(&apos;name.last&apos;).equals(&apos;Ghost&apos;). where(&apos;age&apos;).gt(17).lt(66). where(&apos;likes&apos;).in([&apos;vaporizing&apos;, &apos;talking&apos;]). limit(10). sort(&apos;-occupation&apos;). select(&apos;name occupation&apos;). exec(callback); 可以在API文档中查看全部的Query辅助函数列表。 引用其它的documentMongoDB没有joins功能，但是有时我们想引用其它collections中的文档。这就是[population][]的由来。查看如何在查询结果中包含其他collection的document。 流你可以流式从MongoDB中查询文档。调用Query#cursor()会返回QueryCursor实例。 下一章 —— Validation","tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://dreamflyingcat.github.io/tags/mongoose/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://dreamflyingcat.github.io/tags/mongoDB/"},{"name":"node.js","slug":"node-js","permalink":"https://dreamflyingcat.github.io/tags/node-js/"}]},{"title":"mongoose v5.0.12 中文API - Models","date":"2018-04-09T04:14:21.995Z","path":"2018/04/09/mongoose-Models/","text":"官方原版：http://mongoosejs.com引用请注明出处和转载请注明出处 ModelsModes是由Schema编译而成的假想（fancy）构造器，具有抽象属性和行为。Model的每一个实例（instance）就是一个document。document可以保存到数据库和从数据库返回。document的创建和搜索均可以通过操作model完成。 定义你的第一个Modelvar schema = new mongoose.Schema({ name: &apos;string&apos;, size: &apos;string&apos; }); var Tank = mongoose.model(&apos;Tank&apos;, schema); 第一个参数是Model对应的collection名称的但是形式。因此，对于上面的实例，Tank model对应名称为tanks的collection。Model是由Schema编译生产的，在调用.model()之前，需要先定义好Schema。 创建documentsDocuments是Model的实例，创建和保存document到数据库非常的简单： var Tank = mongoose.model(&apos;Tank&apos;, yourSchema); var small = new Tank({ size: &apos;small&apos; }); small.save(function (err) { if (err) return handleError(err); // saved! }) // or Tank.create({ size: &apos;small&apos; }, function (err, small) { if (err) return handleError(err); // saved! }) Document的创建和删除必须在mongoose connection建立之后才会执行。每一个model会关联一个connection，如果你使用mongoose.model()，创建的model会使用默认的mongoose connection。 mongoose.connect(&apos;localhost&apos;, &apos;gettingstarted&apos;); 如果你自定义了一个connection，可以使用该connection的model()函数。 var connection = mongoose.createConnection(&apos;mongodb://localhost:27017/test&apos;); var Tank = connection.model(&apos;Tank&apos;, yourSchema); QueryingMongoose查询文档非常的便利，它提供非常丰富的MongoDB查询语法。可以使用models的find,findById,findOne,或者where等静态语法查询。 Tank.find({ size: &apos;small&apos; }).where(&apos;createdDate&apos;).gt(oneYearAgo).exec(callback); 更详细的Query api使用方法请查看querying章节。 RemovingModels提供remove静态方法用来移除所有符合提交的documents。 Tank.remove({ size: &apos;large&apos; }, function (err) { if (err) return handleError(err); // removed! }); Updating每个model都有自己的update方法用于修改数据库中的documents，并且该方法不会返回被修改的文档。更多详情可查看API文档。 更多API docs还提供了很多其他的可用方法，例如count, mapReduce, aggregate, and more. 下一章 —— Documents","tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://dreamflyingcat.github.io/tags/mongoose/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://dreamflyingcat.github.io/tags/mongoDB/"},{"name":"node.js","slug":"node-js","permalink":"https://dreamflyingcat.github.io/tags/node-js/"}]},{"title":"mongoose v5.0.12 中文API - Documents","date":"2018-04-09T04:13:15.282Z","path":"2018/04/09/mongoose-Documents/","text":"官方原版：http://mongoosejs.com引用请注明出处和转载请注明出处 DocumentsMongoose documents和数据库中存储的document一一对应。每一个document都是它的Model的实例。 检索Mongoose提供了丰富的方法，从MongoDB中检索document，详情请查看[querying][]章节。 更新有很多的方法可以更新documents，我们首先了解传统的方法findById： Tank.findById(id, function (err, tank) { if (err) return handleError(err); tank.size = &apos;large&apos;; tank.save(function (err, updatedTank) { if (err) return handleError(err); res.send(updatedTank); }); }); 你也可以使用.set()方法修改document。下例中，将tank.size=&#39;large&#39;;，修改为tank.set({ size: &#39;large&#39; })； Tank.findById(id, function (err, tank) { if (err) return handleError(err); tank.set({ size: &apos;large&apos; }); tank.save(function (err, updatedTank) { if (err) return handleError(err); res.send(updatedTank); }); }); 上面的方法首先从mongo中检索文档，然后发出修改命令（调用save触发）。如果我们的应用程序不需要返回document，只想直接修改数据库中的document，Model#update更适合我们： Tank.update({ _id: id }, { $set: { size: &apos;large&apos; }}, callback); 如果我们的应用程序想要返回document，我们最好使用下面的方法会： Tank.findByIdAndUpdate(id, { $set: { size: &apos;large&apos; }}, { new: true }, function (err, tank) { if (err) return handleError(err); res.send(tank); }); findAndUpdate/Remove静态方法最多只修改一个document，可以只调用一次就完成数据库中数据的修改，findAndModify`主体有多种不同的使用方法，详情查看API文档。 请注意findAndUpdate/Remove修改documents之前并不会执行任何的hooks或者validation。你可以在该函数的option参数中设置runValidators属性为true开启本次更新的documents子集的验证。然而，如果你需要hooks和全部document validation，首先需要查询document，然后再save()它们。 验证关于Documents保存之前的验证，详情请查看API文档或者validation章节。 重写你可以通过.set()方法重写document。该方法修改数据库中保存的文档非常的方便。 Tank.findById(id, function (err, tank) { if (err) return handleError(err); // Now `otherTank` is a copy of `tank` otherTank.set(tank); }); 下一章 —— Subdocuments","tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://dreamflyingcat.github.io/tags/mongoose/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://dreamflyingcat.github.io/tags/mongoDB/"},{"name":"node.js","slug":"node-js","permalink":"https://dreamflyingcat.github.io/tags/node-js/"}]},{"title":"mongoose v5.0.12 中文API - Connections","date":"2018-04-09T04:12:24.649Z","path":"2018/04/09/mongoose-Connections/","text":"官方原版：http://mongoosejs.com引用请注明出处和转载请注明出处 Connections你可以使用mongoose.connect()方法连接mongoDB数据库。 mongoose.connect(&apos;mongodb://localhost/myapp&apos;); 这是连接运行在本地的Mongodb服务上（默认使用27017端口）的myapp数据库所需要的最少的参数，如果连接失败尝试修改localhost为127.0.0.1再试试，可能是因为改变了localhost的值导致了连接失败。 你可以在uri中指定更多的参数： mongoose.connect(&apos;mongodb://username:password@host:port/database?options...&apos;); 点击查看更多入参详情。 缓冲操作你可以在mongoose连接到mongoDB之前就使用model操作数据库： nongoose.connect(&apos;mongodb://localhost/myapp&apos;); var MyModel = mongoose.model(&apos;Test&apos;, new Schema({ name: String })); // Works MyModel.findOne(function(error, result) { /* ... */ }); 因为mongoose内部调用了缓冲模型函数，这种缓冲很方便，但也是常见的混乱来源。如果你在连接mongoDB之前调用models，mongoose默认不会抛出任何的错误。 var MyModel = mongoose.model(&apos;Test&apos;, new Schema({ name: String })); // Will just hang until mongoose successfully connects MyModel.findOne(function(error, result) { /* ... */ }); setTimeout(function() { mongoose.connect(&apos;mongodb://localhost/myapp&apos;); }, 60000); 可以在你的schema中传入bufferCommands选项禁用缓冲。如果你开启了缓冲而且你的连接挂掉了，可以尝试关闭缓冲然后查看你是否正确的建立了连接。也可以全局关闭缓冲： mongoose.set(&apos;bufferCommands&apos;, false); 选项(Options)Mongoose的connect方法第二个参数为options对象，该对象会被传递给底层驱动程序，选项中的设置优先于连接字符串中传递的选项。 mongoose.connect(uri, options); connect()的参数——options的完整的选项列表可以点击mongoDB node驱动文档查看。除了下面的例外情况，mongoose会将options中的选项原封不动的传递给驱动。 bufferCommands – 是否开启mongoose的buffering, 该属性并不会传递给MongoDB底层驱动。 user/pass – 用于验证的用户名和密码。这两个选项为mongoose专用的，对应mongoDB驱动的auth.user和auth.password属性。 autoIndex – mongoose默认在建立连接时为schema中定义index的字段自动创建索引，该特性虽然有利于开发，但是对性能有很大的影响，不利于大型项目生产部署。设置autoIndex为false，mongoose会禁用自动创建索引功能。 dbName – 在连接字符串中指明连接和重写的数据库名称。如果你使用mongodb+srv语法连接 MongoDB Atlas，需要使用dbname选项指明连接的数据库，因为在连接字符串中无法指明。 下面的选项对于mongoose的调试（tuning mongoose不知道如何翻译，望高人指点）非常重要： autoReconnect - 连接断开时候底层的MongoDB驱动会自动尝试重新连接，除非你是想要管理自己的连接池的非常高级的用户，否则请勿将此选项设置为false。 reconnectTries - 如果到单个服务器或mongos代理（而不是副本集）的连接断开，MongoDB驱动程序将每隔reconnectInterval时间尝试重连，直到reconnectTries后放弃尝试，然后mongoose连接将触发reconnectFailed事件。 此选项对副本集连接不起任何作用。 reconnectInterval - 详情查看reconnectTries。 promiseLibrary - 设置底层驱动的promise librarypoolSize - MongoDB驱动程序为此连接保持打开的最大套接字数量。poolSize默认为5.请记住，从MongoDB 3.4开始，MongoDB一次只允许每个套接字执行一个操作，因此如果你增加操作，可能会导致一些慢的操作阻塞速度更快的查询。 bufferMaxEntries - 当驱动程序断开连接时，MongoDB驱动程序有自己的缓冲机制。如果你希望数据库操作在未连接时立即失败，请将此选项设置为0，并设置schema的bufferCommands为false，而不是等待重新连接。 例子const options = { useMongoClient: true, autoIndex: false, // Don&apos;t build indexes reconnectTries: Number.MAX_VALUE, // Never stop trying to reconnect reconnectInterval: 500, // Reconnect every 500ms poolSize: 10, // Maintain up to 10 socket connections // If not connected, return errors immediately rather than waiting for reconnect bufferMaxEntries: 0 }; mongoose.connect(uri, options); 回调函数connect()函数接受一个回调函数作为参数，返回一个promise。 mongoose.connect(uri, options, function(error) { // Check error in initial connection. There is no 2nd param to the callback. }); // Or using promises mongoose.connect(uri, options).then( () =&gt; { /** ready to use. The `mongoose.connect()` promise resolves to undefined. */ }, err =&gt; { /** handle initial connection error */ } ); 连接字符串选项您还可以在连接字符串中指明驱动选项用于URI查询的参数。这仅适用于传递给MongoDB驱动程序的选项。您不能在查询字符串中设置特定于Mongoose的选项，如bufferCommands。 mongoose.connect(&apos;mongodb://localhost:27017/test?connectTimeoutMS=1000&amp;bufferCommands=false&apos;); // The above is equivalent to: mongoose.connect(&apos;mongodb://localhost:27017/test&apos;, { connectTimeoutMS: 1000 // Note that mongoose will **not** pull `bufferCommands` from the query string }); 将选项放入查询字符串的缺点是查询字符串选项难以阅读。 优点是你只需要一个配置选项，即URI，而不需要独立的配置socketTimeoutMS，connectTimeoutMS等多个选项。最佳实践是在连接字符串中放置开发和生产之间可能不同的选项，如replicaSet或ssl， 应该保持不变的选项，如connectTimeoutMS或poolSize放在options的对象中。 MongoDB文档有支持的连接字符串选项的完整列表。 ###keepAlive注意事项 对于长期运行的应用程序需要谨慎设置keepAlive的值（毫秒为单位）。如果不设置该参数，你可能隔三差五的看到connection closed的错误提示而且不知道原因。如果是这样，阅读完此文后，您可能会决定启用keepAlive： mongoose.connect(uri, { keepAlive: 120 }); 副本集连接要连接到副本集，请传入以逗号分隔的主机列表而不是单个主机。 mongoose.connect(&apos;mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]&apos; [, options]); 支持多个multi-mongos在集群中您还可以连接到多个mongos实例以实现高性能。对于mongoose 5.x，连接多个mongos您不需要任何特殊的选项。 // Connect to 2 mongos servers mongoose.connect(&apos;mongodb://mongosA:27501,mongosB:27501&apos;, cb); 多连接目前为止我们学习了使用mongoose默认连接连接到mongoDB。有时我们需要打开多个到mongo的连接，每个连接的读写设置不同，也可能连接到不同的数据库。这种情况下，可以使用mongoose.createConnection()方法，它接受上面提到的所有选项，并给你返回一个新的连接。 const conn = mongoose.createConnection(&apos;mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]&apos;, options); 这个连接之后用于新建和检索模型。模型始终限定到其中的一个连接。 当您调用mongoose.connect()时，Mongoose会创建一个默认连接。您可以使用mongoose.connection访问默认连接。 连接池每个连接无论是使用mongoose.connect还是mongoose.createConnection创建的，都需要内部可配置的连接池支持，默认最大为5。可以使用连接选项调整池大小： // With object options mongoose.createConnection(uri, { poolSize: 4 }); const uri = &apos;mongodb://localhost/test?poolSize=4&apos;; mongoose.createConnection(uri); 5.x版本改变的选项如果从4.x升级到5.x并且没有在4.x中使用useMongoClient选项，则可能会看到以下弃用警告： the server/replset/mongos options are deprecated, all their options are supported at the top level of the options object 在较早版本的MongoDB驱动程序中，您必须为服务器连接、副本集连接和mongos连接指定不同的选项： mongoose.connect(myUri, { server: { socketOptions: { socketTimeoutMS: 0, keepAlive: true }, reconnectTries: 30 }, replset: { socketOptions: { socketTimeoutMS: 0, keepAlive: true }, reconnectTries: 30 }, mongos: { socketOptions: { socketTimeoutMS: 0, keepAlive: true }, reconnectTries: 30 } }); 在mongoose v5.x中，您可以在顶层声明这些选项，而无需额外的嵌套。 以下是所有支持选项的列表。 // Equivalent to the above code mongoose.connect(myUri, { socketTimeoutMS: 0, keepAlive: true, reconnectTries: 30 }); 下一章 —— Models","tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://dreamflyingcat.github.io/tags/mongoose/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://dreamflyingcat.github.io/tags/mongoDB/"},{"name":"node.js","slug":"node-js","permalink":"https://dreamflyingcat.github.io/tags/node-js/"}]},{"title":"mongoose v5.0.12 中文API - 纲要","date":"2018-04-09T04:09:45.965Z","path":"2018/04/09/mongoose-Schema/","text":"官方原版：http://mongoosejs.com引用请注明出处和转载请注明出处 纲要如果你还不了解Mongoose如何工作，请先阅读quickstart章节。如果你是从4.x版本迁移到5.x，请花点时间阅读迁移指南。 定义你的schema在mongoose中一切都是从schema开始的，schema会被映射为mongoDB中的collection，并且定义了collection中documents的形式。 var mongoose = require(&apos;mongoose&apos;); var Schema = mongoose.Schema; var blogSchema = new Schema({ title: String, author: String, body: String, comments: [{ body: String, date: Date }], date: { type: Date, default: Date.now }, hidden: Boolean, meta: { votes: Number, favs: Number } }); 如果你之后想额外的增加keys，可以使用Schema#add方法。 在我们的blogSchema中每个key对应document中的一个字段并且有一个关联的SchemaType。例如，我们定义的title字段的SchemaType为String类型，date的SchemaType是Date类型。keys也可以定义为嵌套的objects，包含了进一步的键/类型的定义，例如上面的meta属性。 下面是允许的schemaTypes类型： String Number Date Buffer Boolean Mixed ObjectId Array 点击查看更多的SchemaType。 Schemas不仅定义了文档和其结构，还定义了model的实例方法、静态方法、复合索引和属于文档中间件的生命周期钩子函数。 创建一个model我们需要将我们定义的blogSchema转换成一个model才能工作。我们将blogSchema传给mongoose.model(modelName, schema); var Blog = mongoose.model(&apos;Blog&apos;, blogSchema); // ready to go! 实例方法document是model的实例。document有许多内置的实例方法，我们也可以自定义document的实例方法。 // define a schema var animalSchema = new Schema({ name: String, type: String }); // assign a function to the &quot;methods&quot; object of our animalSchema animalSchema.methods.findSimilarTypes = function(cb) { return this.model(&apos;Animal&apos;).find({ type: this.type }, cb); }; 现在所有的animal实例都拥有findSimilarTypes方法。 var Animal = mongoose.model(&apos;Animal&apos;, animalSchema); var dog = new Animal({ type: &apos;dog&apos; }); dog.findSimilarTypes(function(err, dogs) { console.log(dogs); // woof }); 重写默认的mongoose document方法可能导致无法预知的结果，详情请点击查看。 不要使用箭头函数声明方法，因为箭头函数阻止绑定this，所以你的方法无法访问document，上例将无法正常工作。 静态方法在model上绑定静态方法也很简单，继续上面的animalSchema示例： // assign a function to the &quot;statics&quot; object of our animalSchema animalSchema.statics.findByName = function(name, cb) { return this.find({ name: new RegExp(name, &apos;i&apos;) }, cb); }; var Animal = mongoose.model(&apos;Animal&apos;, animalSchema); Animal.findByName(&apos;fido&apos;, function(err, animals) { console.log(animals); }); 要使用箭头函数声明方法，因为箭头函数阻止绑定this，在上例中使用箭头函数将无法正常工作。 查询助手你也可以像添加实例方法那样给mongoose的查询添加查询助手函数。查询助手方法可以帮你建立链式查询模式。 animalSchema.query.byName = function(name) { return this.find({ name: new RegExp(name, &apos;i&apos;) }); }; var Animal = mongoose.model(&apos;Animal&apos;, animalSchema); Animal.find().byName(&apos;fido&apos;).exec(function(err, animals) { console.log(animals); }); 索引MongoDB支持secondary indexes 。在mongoose中，我们可以在schema的path级别和schema级别上定义索引。复合索引只能在schema级别上定义。 var animalSchema = new Schema({ name: String, type: String, tags: { type: [String], index: true } // field level }); animalSchema.index({ name: 1, type: -1 }); // schema level 当应用程序启动时，mongoose会自动创建你在schema中定义的索引。mongoose为每个index顺序执行createIndex，当所有的createIndex执行成功或者发生错误时会触发model上的index事件。虽然这个特性有利于开发，但是建议在生成环境中关闭它，因为创建索引会对性能造成很大的影响。可以通过设置autoIndex选择值为false在schema级别上或者全局关闭自动创建索引。 mongoose.connect(&apos;mongodb://user:pass@localhost:port/database&apos;, { autoIndex: false }); // or mongoose.createConnection(&apos;mongodb://user:pass@localhost:port/database&apos;, { autoIndex: false }); // or animalSchema.set(&apos;autoIndex&apos;, false); // or new Schema({..}, { autoIndex: false }); 当所有index创建成功或者发生错误时会触发model上的index事件。 // Will cause an error because mongodb has an _id index by default that // is not sparse animalSchema.index({ _id: 1 }, { sparse: true }); var Animal = mongoose.model(&apos;Animal&apos;, animalSchema); Animal.on(&apos;index&apos;, function(error) { // &quot;_id index cannot be sparse&quot; console.log(error.message); }); 点击查看Model#ensureIndexes方法。 虚拟属性document的虚拟属性可以被访问和设置，但是不会被存储到MongoDB中。getters用于格式化和组合字段，setter用于将一个值结构到数据库中的多个字段上。 // define a schema var personSchema = new Schema({ name: { first: String, last: String } }); // compile our model var Person = mongoose.model(&apos;Person&apos;, personSchema); // create a document var axl = new Person({ name: { first: &apos;Axl&apos;, last: &apos;Rose&apos; } }); 假设你想输出一个人的全名，你需要这样做： console.log(axl.name.first + &apos; &apos; + axl.name.last); // Axl Rose 每次都要连接first name和last name是很麻烦的事情。如果你想要对name做些其他的处理，例如移除符号该怎么办呢？你可以定义一个fullname的虚拟属性的getter，该值不会被保存到MongoDB中。 personSchema.virtual(&apos;fullName&apos;).get(function () { return this.name.first + &apos; &apos; + this.name.last; }); 现在你可以调用getter函数获取fullName字段的值： console.log(axl.fullName); // Axl Rose mongoose不会输出虚拟的字段，当你使用toJSON()或者toObject()函数时（或者对document使用JSON.stringify()），可以给toJSON()或者toObject()传{ virtuals: true }`获取虚拟字段。 你可以自定义虚拟字段的setter函数，通过虚拟的fullName字段一次性设置first name和last name的值。 personSchema.virtual(&apos;fullName&apos;). get(function() { return this.name.first + &apos; &apos; + this.name.last; }). set(function(v) { this.name.first = v.substr(0, v.indexOf(&apos; &apos;)); this.name.last = v.substr(v.indexOf(&apos; &apos;) + 1); }); axl.fullName = &apos;William Rose&apos;; // Now `axl.name.first` is &quot;William&quot; 虚拟字段的setters会在其他的validation之前运行。所以即使first和last字段值必须，上例依然会执行。 只有非虚拟字段可以用于查询和选择的字段，因为虚拟字段不会被存到MongoDB中，所以不能用于查询。 别名别名属于特殊的虚拟字段，其getter和setter用于设置和获取另一个字段。为了节省带宽，你可以使用简短的字段名称用于存储到数据库，使用更长的语义化的别名提高代码可读性。 var personSchema = new Schema({ n: { type: String, // Now accessing `name` will get you the value of `n`, and setting `n` will set the value of `name` alias: &apos;name&apos; } }); // Setting `name` will propagate to `n` var person = new Person({ name: &apos;Val&apos; }); console.log(person); // { n: &apos;Val&apos; } console.log(person.toObject({ virtuals: true })); // { n: &apos;Val&apos;, name: &apos;Val&apos; } console.log(person.name); // &quot;Val&quot; person.name = &apos;Not Val&apos;; console.log(person); // { n: &apos;Not Val&apos; } 选项schemas有一些可配置的选项可直接传递给构造器或者set： new Schema({..}, options); // or var schema = new Schema({..}); schema.set(option, value); 有效的选项： * autoIndex * bufferCommands * capped * collection * id * _id * minimize * read * shardKey * strict * strictQuery * toJSON * toObject * typeKey * validateBeforeSave * versionKey * collation * skipVersioning * timeStamps autoIndex当应用程序启动时，mongoose会发出createIndex命令自动创建你在schema中定义的索引。mongoose v3版本索引默认在后台创建索引。如果你希望关闭自动创建选择手动创建索引时，设置autoIndex选择值为false，并调用model的ensureIndexes方法。 var schema = new Schema({..}, { autoIndex: false }); var Clock = mongoose.model(&apos;Clock&apos;, schema); Clock.ensureIndexes(callback); bufferCommands如果connection断掉，mongoose会默认缓冲命令，直到驱动重连才会执行命令。设置bufferCommands值为false关闭缓冲。 var schema = new Schema({..}, { bufferCommands: false }); 设置schema的bufferCommands选项会重写全局的bufferCommands选项： mongoose.set(&apos;bufferCommands&apos;, true); // Schema option below overrides the above, if the schema option is set. var schema = new Schema({..}, { bufferCommands: false }); cappedMongoose支持设置MongoDB集合大小的上限值。设置capped属性限制MongoDB集合的最大值，单位bytes。 new Schema({..}, { capped: 1024 }); 如果你想传其他的选项，例如max或者autoIndexId，可以将capped值设置为一个对象。这种情况下，size属性为必传值。 new Schema({..}, { capped: { size: 1024, max: 1000, autoIndexId: true } }); collectionMongoose默认使用utils.tocollectionname方法生成集合的集合名称。该方法会生成复数形式的名称。如果你需要自定义集合名称，可以传入下面的选项。 var dataSchema = new Schema({..}, { collection: &apos;data&apos; }); idmongoose默认为每一个schema分配一个虚拟的id getter，该方法返回document的_id字段，类型为string或者ObjectId（哈希字符串）。如果你的schema不需要id getter，给schema的构造函数传option禁用该功能。 // default behavior var schema = new Schema({ name: String }); var Page = mongoose.model(&apos;Page&apos;, schema); var p = new Page({ name: &apos;mongodb.org&apos; }); console.log(p.id); // &apos;50341373e894ad16347efe01&apos; // disabled id var schema = new Schema({ name: String }, { id: false }); var Page = mongoose.model(&apos;Page&apos;, schema); var p = new Page({ name: &apos;mongodb.org&apos; }); console.log(p.id); // undefined _id如果没有禁用，mongoose默认为每一个schema分配_id字段，值为ObjectId类型，与MongoDB默认行为一致。如果你的schema不需要id getter，给schema的构造函数传option禁用该功能。 你只能在sub-document中使用此选项，因为如果没有_id，将document保存到数据库时会报错。 // default behavior var schema = new Schema({ name: String }); var Page = mongoose.model(&apos;Page&apos;, schema); var p = new Page({ name: &apos;mongodb.org&apos; }); console.log(p); // { _id: &apos;50341373e894ad16347efe01&apos;, name: &apos;mongodb.org&apos; } // disabled _id var childSchema = new Schema({ name: String }, { _id: false }); var parentSchema = new Schema({ children: [childSchema] }); var Model = mongoose.model(&apos;Model&apos;, parentSchema); Model.create({ children: [{ name: &apos;Luke&apos; }] }, function(error, doc) { // doc.children[0]._id will be undefined }); minimizemongoose默认不存储空对象，实现schemas最小化。 var schema = new Schema({ name: String, inventory: {} }); var Character = mongoose.model(&apos;Character&apos;, schema); // will store `inventory` field if it is not empty var frodo = new Character({ name: &apos;Frodo&apos;, inventory: { ringOfPower: 1 }}); Character.findOne({ name: &apos;Frodo&apos; }, function(err, character) { console.log(character); // { name: &apos;Frodo&apos;, inventory: { ringOfPower: 1 }} }); // will not store `inventory` field if it is empty var sam = new Character({ name: &apos;Sam&apos;, inventory: {}}); Character.findOne({ name: &apos;Sam&apos; }, function(err, character) { console.log(character); // { name: &apos;Sam&apos; } }); 设置minimize选项重写默认行为，下例中会存储空对象： var schema = new Schema({ name: String, inventory: {} }, { minimize: false }); var Character = mongoose.model(&apos;Character&apos;, schema); // will store `inventory` if empty var sam = new Character({ name: &apos;Sam&apos;, inventory: {}}); Character.findOne({ name: &apos;Sam&apos; }, function(err, character) { console.log(character); // { name: &apos;Sam&apos;, inventory: {}} }); readmongoose允许在schema级别设置查询＃读取选项，为我们提供一种将默认ReadPreferences应用于从模型派生的所有查询的方法。 var schema = new Schema({..}, { read: &apos;primary&apos; }); // also aliased as &apos;p&apos; var schema = new Schema({..}, { read: &apos;primaryPreferred&apos; }); // aliased as &apos;pp&apos; var schema = new Schema({..}, { read: &apos;secondary&apos; }); // aliased as &apos;s&apos; var schema = new Schema({..}, { read: &apos;secondaryPreferred&apos; }); // aliased as &apos;sp&apos; var schema = new Schema({..}, { read: &apos;nearest&apos; }); // aliased as &apos;n&apos; 每个pref允许使用简单的别名，不必须使用全拼，例如’secondaryPreferred’，防止拼写错误。 读选项允许我们设置tag，指明驱动应该试图读取的replicaSet。更多tag设置详情点击查看。 注意：你可以在连接数据库时，指明驱动的读选项的pref strategy。 // pings the replset members periodically to track network latency var options = { replset: { strategy: &apos;ping&apos; }}; mongoose.connect(uri, options); var schema = new Schema({..}, { read: [&apos;nearest&apos;, { disk: &apos;ssd&apos; }] }); mongoose.model(&apos;JellyBean&apos;, schema); shardKey当我们有一个分片的MongoDB架构时，需要使用hardKey（片键）选项。每个分片集合都有一个分片键，它必须存在于所有插入/更新操作中。我们只需要在schema属性中配置shardKey。 new Schema({ .. }, { shardKey: { tag: 1, name: 1 }}) 请注意，Mongoose不会为你发送shardcollection命令。 你必须自己配置你的碎片。 strictmongoose默认开启strict模式，确保传递给model却没有在schema中声明的字段，不会被保存到数据库中。 var thingSchema = new Schema({..}) var Thing = mongoose.model(&apos;Thing&apos;, thingSchema); var thing = new Thing({ iAmNotInTheSchema: true }); thing.save(); // iAmNotInTheSchema is not saved to the db // set to false.. var thingSchema = new Schema({..}, { strict: false }); var thing = new Thing({ iAmNotInTheSchema: true }); thing.save(); // iAmNotInTheSchema is now saved to the db!! 该选项也影响doc.set()执行的结果。 var thingSchema = new Schema({..}) var Thing = mongoose.model(&apos;Thing&apos;, thingSchema); var thing = new Thing; thing.set(&apos;iAmNotInTheSchema&apos;, true); thing.save(); // iAmNotInTheSchema is not saved to the db 通过给model的实例传递第二个参数重写该选项。 var Thing = mongoose.model(&apos;Thing&apos;); var thing = new Thing(doc, true); // enables strict mode var thing = new Thing(doc, false); // disables strict mode strict值也可以被设置为throw，如果保存坏数据到数据库会报错而不是忽略该数据。 请注意，不设置schema的option时，model实例设置任何的未在schema中声明的key/val键值对都会被忽视。 var thingSchema = new Schema({..}) var Thing = mongoose.model(&apos;Thing&apos;, thingSchema); var thing = new Thing; thing.iAmNotInTheSchema = true; thing.save(); // iAmNotInTheSchema is never saved to the db strictQuery为了向后兼容，strict选项在查询时不会用于过滤字段。 const mySchema = new Schema({ field: Number }, { strict: true }); const MyModel = mongoose.model(&apos;Test&apos;, mySchema); // Mongoose will **not** filter out `notInSchema: 1`, despite `strict: true` MyModel.find({ notInSchema: 1 }); strict选项也会用于更新数据。 // Mongoose will strip out `notInSchema` from the update if `strict` is // not `false` MyModel.updateMany({}, { $set: { notInSchema: 1 } }); mongoose提供了一个独立的选项strictQuery用于查询时过滤字段。 const mySchema = new Schema({ field: Number }, { strict: true, strictQuery: true // Turn on strict mode for query filters }); const MyModel = mongoose.model(&apos;Test&apos;, mySchema); // Mongoose will strip out `notInSchema: 1` because `strictQuery` is `true` MyModel.find({ notInSchema: 1 }); toJSON与toObject选项相同，但是toJSON方法只能被documents调用 var schema = new Schema({ name: String }); schema.path(&apos;name&apos;).get(function (v) { return v + &apos; is my name&apos;; }); schema.set(&apos;toJSON&apos;, { getters: true, virtuals: false }); var M = mongoose.model(&apos;Person&apos;, schema); var m = new M({ name: &apos;Max Headroom&apos; }); console.log(m.toObject()); // { _id: 504e0cd7dd992d9be2f20b6f, name: &apos;Max Headroom&apos; } console.log(m.toJSON()); // { _id: 504e0cd7dd992d9be2f20b6f, name: &apos;Max Headroom is my name&apos; } // since we know toJSON is called whenever a js object is stringified: console.log(JSON.stringify(m)); // { &quot;_id&quot;: &quot;504e0cd7dd992d9be2f20b6f&quot;, &quot;name&quot;: &quot;Max Headroom is my name&quot; } 点击查看所有可用的toJSON/toObject选项。 toObjectdocument可以调用toObject方法将mongoose document转换为普通的JavaScript对象。该方法接受一些参数，我们可以声明这些选项并默认应用于所有的schema documents，而不是在每个文档的基础上应用这些选项。 想要在console.log中输出所有的虚拟字段，在toObject选项中设置{ getters: true }： var schema = new Schema({ name: String }); schema.path(&apos;name&apos;).get(function (v) { return v + &apos; is my name&apos;; }); schema.set(&apos;toObject&apos;, { getters: true }); var M = mongoose.model(&apos;Person&apos;, schema); var m = new M({ name: &apos;Max Headroom&apos; }); console.log(m); // { _id: 504e0cd7dd992d9be2f20b6f, name: &apos;Max Headroom is my name&apos; } 点击查看这里所有可用的toObject选项。 typeKey如果schema中的object定义了’type’字段，mongoose默认把它理解为字段类型声明。 // Mongoose interprets this as &apos;loc is a String&apos; var schema = new Schema({ loc: { type: String, coordinates: [Number] } }); 然而有些应用中例如geoJSON，’type’属性是非常重要的，你可以设置’typeKey’选项来控制哪个字段用于声明字段类型。 var schema = new Schema({ // Mongoose interpets this as &apos;loc is an object with 2 keys, type and coordinates&apos; loc: { type: String, coordinates: [Number] }, // Mongoose interprets this as &apos;name is a String&apos; name: { $type: String } }, { typeKey: &apos;$type&apos; }); // A &apos;$type&apos; key means this object is a type declaration validateBeforeSave在document保存到数据库前会自动执行验证器，对于验证失败的文档会阻止保存。如果你想手动控制验证并且让验证失败的document也可以保存到数据库，可以设置validateBeforeSave值为false。 var schema = new Schema({ name: String }); schema.set(&apos;validateBeforeSave&apos;, false); schema.path(&apos;name&apos;).validate(function (value) { return v != null; }); var M = mongoose.model(&apos;Person&apos;, schema); var m = new M({ name: null }); m.validate(function(err) { console.log(err); // Will tell you that null is not allowed. }); m.save(); // Succeeds despite being invalid versionKeymongoose默认在第一次创建文档时为每个document设置versionKey。此值包含了document的内部修订版本号。versionkey选项是一个字符串，用于表示版本控制的路径，默认值为_v。如果与你的应用有冲突，你可以如下例中修改： var schema = new Schema({ name: &apos;string&apos; }); var Thing = mongoose.model(&apos;Thing&apos;, schema); var thing = new Thing({ name: &apos;mongoose v3&apos; }); thing.save(); // { __v: 0, name: &apos;mongoose v3&apos; } // customized versionKey new Schema({..}, { versionKey: &apos;_somethingElse&apos; }) var Thing = mongoose.model(&apos;Thing&apos;, schema); var thing = new Thing({ name: &apos;mongoose v3&apos; }); thing.save(); // { _somethingElse: 0, name: &apos;mongoose v3&apos; } 可以设置versionKey值为false，禁用document的版本号。不要禁用版本号除非你知道你正在做什么。 collation为每个查询和聚合设置默认的collation。 这是一个初学者友好的collationcollation总览。 skipVersioningskipversioning允许阻止版本号更新（例如，内部版本号不会增加即使这些路径更新）。不要这样做，除非你知道你在做什么。对于子文档，使用完全限定的路径将版本号包含在父文档中。 new Schema({..}, { skipVersioning: { dontVersionMe: true } }); thing.dontVersionMe.push(&apos;hey&apos;); thing.save(); // version is not incremented timestamps如果设置了timestamps，mongoose会为你的schema分配createAt和updateAt字段，值为Date类型。 默认情况下，两个字段的名称为createAt和updateAt，设置timestamps.createdAt和timestamps.updatedAt自定义字段名称。 var thingSchema = new Schema({..}, { timestamps: { createdAt: &apos;created_at&apos; } }); var Thing = mongoose.model(&apos;Thing&apos;, thingSchema); var thing = new Thing(); thing.save(); // `created_at` &amp; `updatedAt` will be included useNestedStrictmongoose v4版本执行update()和findOneAndUpdate()操作时只会检查顶级schema的严格模式设置。 var childSchema = new Schema({}, { strict: false }); var parentSchema = new Schema({ child: childSchema }, { strict: &apos;throw&apos; }); var Parent = mongoose.model(&apos;Parent&apos;, parentSchema); Parent.update({}, { &apos;child.name&apos;: &apos;Luke Skywalker&apos; }, function(error) { // Error because parentSchema has `strict: throw`, even though // `childSchema` has `strict: false` }); var update = { &apos;child.name&apos;: &apos;Luke Skywalker&apos; }; var opts = { strict: false }; Parent.update({}, update, opts, function(error) { // This works because passing `strict: false` to `update()` overwrites // the parent schema. }); 如果你设置了useNestedStrict值为true，mongoose在执行updates时会使用child schema的strict选项的值。 var childSchema = new Schema({}, { strict: false }); var parentSchema = new Schema({ child: childSchema }, { strict: &apos;throw&apos;, useNestedStrict: false }); var Parent = mongoose.model(&apos;Parent&apos;, parentSchema); Parent.update({}, { &apos;child.name&apos;: &apos;Luke Skywalker&apos; }, function(error) { // Works! }); Pluggableschema允许使用插件，这样我们将有用的功能打包成插件，在社区或者项目中实现共享。 下一章 —— SchemaTypes","tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://dreamflyingcat.github.io/tags/mongoose/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://dreamflyingcat.github.io/tags/mongoDB/"},{"name":"node.js","slug":"node-js","permalink":"https://dreamflyingcat.github.io/tags/node-js/"}]},{"title":"中文转拼音或首字母模块","date":"2018-04-09T02:49:34.957Z","path":"2018/04/09/中文转拼音模块/","text":"中文转拼音或者首字母 github仓库地址 说明该工具有以下两点功能： 中文转拼音 中文转首字母 可以传入不同的参数控制输出结果。 安装使用npm安装: 1npm install chinese2pinyin 使用const convert = require(&apos;chinese2pinyin&apos;); // 输出拼音ZhongWenZhuanPinYinHuoShouZiMu convert({ cn: &apos;中文转拼音或首字母&apos;, result: &apos;P&apos; }) // 输出首字母ZWZPYHSZM convert({ cn: &apos;中文转拼音或首字母&apos;, result: &apos;F&apos; }) // 输出结果为包含两个key(pinyin和first)的对象 convert({ cn: &apos;中文转拼音或首字母&apos;, result: &apos;A&apos; }) /* 使用threshold */ // threshold=5输出ZWZPYHSZM，threshold=9输出ZhongWenZhuanPinYinHuoShouZiMu convert({ cn: &apos;中文转拼音或首字母&apos;, result: &apos;P&apos;, threshold: 5 }) /* 使用concatKey */ // 输出Zhong_Wen_Zhuan_Pin_Yin_Huo_Shou_Zi_Mu convert({ cn: &apos;中文转拼音或首字母&apos;, result: &apos;P&apos;, concatKey: &apos;_&apos; }) /* 使用remainSpecial */ // remainSpecial为true输出ZW-Z-PYH_SZM，否则输出ZWZPYHSZM convert({ cn: &apos;中文-转-拼音或_首字母&apos;, result: &apos;F&apos;, remainSpecial: true }) /* 使用double */ //double为true输出ZHWZHPYHSHZM，否则输出ZWZPYHSZM convert({ cn: &apos;中文-转-拼音或_首字母&apos;, result: &apos;F&apos;, double: true }) 参数 参数 描述 cn 默认值：空字符串，输入的中文字符串，可包非中文字符，根据remainSpecial值选择是否保留输出 result 默认值：P， 可选值：P(输出拼音)、F(输出首字母)、A(输出对一个对象，包含两个key，pinyin和first) threshold 默认值：undefined，仅result为P时生效，cn长度大于threshold返回首字母，否则返回拼音 concatKey 默认值：undefined，输出结果含有拼音的话，拼音之间用concat连接 remainSpecial 默认值：false，是否保留非中文字符，例如值为true时输入’中文_转_拼音’返回ZhongWen_Zhuan_PinYin double 默认值：false， 是否返回翘舌音（zh、ch、sh）全部生母，还是仅返回一个字母例如zh返回z","tags":[{"name":"node.js","slug":"node-js","permalink":"https://dreamflyingcat.github.io/tags/node-js/"},{"name":"javascript","slug":"javascript","permalink":"https://dreamflyingcat.github.io/tags/javascript/"}]},{"title":"mongoose v5.0.12 中文API - 新手入门","date":"2018-04-08T02:44:02.025Z","path":"2018/04/08/mongoose-新手入门/","text":"官方原版：http://mongoosejs.com引用请注明出处和转载请注明出处 新手入门首先请确定你已经安装了mongoDB和Node.js。接下来使用npm安装mongoose。 $ npm install mongoose 假设我们喜欢毛绒绒的猫咪，想要在mongoDB中记录我们遇见过的每一只猫咪。首先我们要在项目中引入mongoose并且连接到运行在本地MongoDB实例上的test数据库。 // getting-started.js var mongoose = require(&apos;mongoose&apos;); mongoose.connect(&apos;mongodb://localhost/test&apos;); 我们需要知道连接到运行在本地的数据库的结果是成功还是失败： var db = mongoose.connection; db.on(&apos;error&apos;, console.error.bind(console, &apos;connection error:&apos;)); db.once(&apos;open&apos;, function() { // we&apos;re connected! }); 一旦我们发起连接，回调函数会被调用。简洁起见，我们假定下面的代码都写在回调函数中。 在Mongoose中，所有事物都源于模式。参考下面的代码定义kittens。 var kittySchema = mongoose.Schema({ name: String }); 目前为止，我们创建了一个schema，它只有一个属性——字符串类型的name。下一步要将schema编译为一个Model。 var Kitten = mongoose.model(&apos;Kitten&apos;, kittySchema); model是一个class用于构造documents。在这种情况下，每个document都是Kitten的实例，都拥有在schema中声明的属性和行为。让我们创建一个document来代表在路边遇到的一只猫咪。 var silence = new Kitten({ name: &apos;Silence&apos; }); console.log(silence.name); // &apos;Silence&apos; 猫咪可以喵喵叫，我们学习如何给document添加”speak”功能： // NOTE: methods must be added to the schema before compiling it with mongoose.model() kittySchema.methods.speak = function () { var greeting = this.name ? &quot;Meow name is &quot; + this.name : &quot;I don&apos;t have a name&quot;; console.log(greeting); } var Kitten = mongoose.model(&apos;Kitten&apos;, kittySchema); 将方法函数添加到schema实例的methods属性上，方法会被编译到Model的原型上从而让每个实例document都可以访问该方法。 var fluffy = new Kitten({ name: &apos;fluffy&apos; }); fluffy.speak(); // &quot;Meow name is fluffy&quot; 这样猫咪就可以说话啦！到现在我们还没有向mongoDB中保存任何的数据，调用document的save方法保存文档。如果报错，错误对象会包含在回调函数的第一个参数中。 fluffy.save(function (err, fluffy) { if (err) return console.error(err); fluffy.speak(); }); 我们可以通过操作Kitten Model查看曾经遇到过的所有猫咪的文档。 Kitten.find(function (err, kittens) { if (err) return console.error(err); console.log(kittens); }) 我们将mongoDB中所有的猫咪文档全部打印出来了，我们也可以通过名字过滤猫咪，mongoose支持mongoDB丰富的查询语法。 Kitten.find({ name: /^fluff/ }, callback); 上例中会查询所有名字以’fluff’开头的猫咪，并将结果放在数组中返回给回调函数。 Congratulations快速入门到此结束。现在我们成功的创建了一个schema并添加了一个自定义的实例方法，使用Mongoose在MongoDB中保存并查询了kittens的文档。进阶学习前往查看guide或者API文档。 下一章 —— mongoose指南","tags":[{"name":"mongoose","slug":"mongoose","permalink":"https://dreamflyingcat.github.io/tags/mongoose/"},{"name":"mongoDB","slug":"mongoDB","permalink":"https://dreamflyingcat.github.io/tags/mongoDB/"},{"name":"node.js","slug":"node-js","permalink":"https://dreamflyingcat.github.io/tags/node-js/"}]}]