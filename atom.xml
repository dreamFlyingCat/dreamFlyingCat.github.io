<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dreamFlyingCat&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/23d136dc82cfca661ae65f0f6a7d1289</icon>
  <subtitle>书山有路勤为径，学海无涯苦作舟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dreamflyingcat.github.io/"/>
  <updated>2018-04-09T05:58:09.429Z</updated>
  <id>https://dreamflyingcat.github.io/</id>
  
  <author>
    <name>刘亚利</name>
    <email>1293925288@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mongoose v5.0.12 中文API - Validation</title>
    <link href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Validation/"/>
    <id>https://dreamflyingcat.github.io/2018/04/09/mongoose-Validation/</id>
    <published>2018-04-09T04:17:33.740Z</published>
    <updated>2018-04-09T05:58:09.429Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方原版：<a href="http://mongoosejs.com" target="_blank" rel="noopener">http://mongoosejs.com</a><br>引用请注明出处和转载请注明出处</p></blockquote><h2 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h2><p>在我们使用确定的validation语法前，请先记住下面的规则：</p><ul><li>Validation是在SchemaType中定义的额；</li><li>Validation是中间件的内部组件，schema默认使用<code>pre(&#39;save&#39;)</code>钩子函数注册validation；</li><li>你可以使用<code>doc.validate(callback)</code>或者<code>doc.validateSync()</code>进行手动的validation。</li><li>除了<code>required</code>验证器，validate不会在undefined值上运行；</li><li>validate是异步递归执行的，如果顶层document调用<a href="http://mongoosejs.com/docs/api.html#model_Model-save" target="_blank" rel="noopener">Model#save</a>，sub-document的验证也会执行。一旦发生错误，<a href="http://mongoosejs.com/docs/api.html#model_Model-save" target="_blank" rel="noopener">Model#save</a>的回调函数会收它。</li><li>validation支持自定义。</li></ul><hr><pre><code>var schema = new Schema({name: {    type: String,    required: true}});var Cat = db.model(&apos;Cat&apos;, schema);// This cat has no name :(var cat = new Cat();cat.save(function(error) {assert.equal(error.errors[&apos;name&apos;].message,    &apos;Path `name` is required.&apos;);error = cat.validateSync();assert.equal(error.errors[&apos;name&apos;].message,    &apos;Path `name` is required.&apos;);});</code></pre><h3 id="内置验证器"><a href="#内置验证器" class="headerlink" title="内置验证器"></a>内置验证器</h3><p>Mongoose提供了一些内置的验证器。</p><ul><li>所有的<a href="http://mongoosejs.com/docs/schematypes.html" target="_blank" rel="noopener">SchemaType</a>都有<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType-required" target="_blank" rel="noopener">required</a>验证器，其使用<code>checkRequired()</code>函数判断值是否符合要求。</li><li>Numbers有专属的<a href="http://mongoosejs.com/docs/api.html#schema_number_SchemaNumber-min" target="_blank" rel="noopener">min</a>和<a href="http://mongoosejs.com/docs/api.html#schema_number_SchemaNumber-max" target="_blank" rel="noopener">max</a>验证器；</li><li>String有专属<a href="http://mongoosejs.com/docs/api.html#schema_string_SchemaString-enum" target="_blank" rel="noopener">enum</a>、<a href="http://mongoosejs.com/docs/api.html#schema_string_SchemaString-match" target="_blank" rel="noopener">match</a>、<a href="http://mongoosejs.com/docs/api.html#schema_string_SchemaString-maxlength" target="_blank" rel="noopener">maxlength</a>、<a href="http://mongoosejs.com/docs/api.html#schema_string_SchemaString-minlength" target="_blank" rel="noopener">minlength</a>验证器。 </li></ul><p>上面的每一个验证器链接提供关于如何使用它们和定制错误信息。</p><pre><code>   var breakfastSchema = new Schema({    eggs: {        type: Number,        min: [6, &apos;Too few eggs&apos;],        max: 12    },    bacon: {        type: Number,        required: [true, &apos;Why no bacon?&apos;]    },    drink: {        type: String,        enum: [&apos;Coffee&apos;, &apos;Tea&apos;],        required: function() {            return this.bacon &gt; 3;        }    }});var Breakfast = db.model(&apos;Breakfast&apos;, breakfastSchema);var badBreakfast = new Breakfast({    eggs: 2,    bacon: 0,    drink: &apos;Milk&apos;});var error = badBreakfast.validateSync();assert.equal(error.errors[&apos;eggs&apos;].message,  &apos;Too few eggs&apos;);assert.ok(!error.errors[&apos;bacon&apos;]);assert.equal(error.errors[&apos;drink&apos;].message,  &apos;`Milk` is not a valid enum value for path `drink`.&apos;);badBreakfast.bacon = 5;badBreakfast.drink = null;error = badBreakfast.validateSync();assert.equal(error.errors[&apos;drink&apos;].message, &apos;Path `drink` is required.&apos;);badBreakfast.bacon = null;error = badBreakfast.validateSync();assert.equal(error.errors[&apos;bacon&apos;].message, &apos;Why no bacon?&apos;);</code></pre><h3 id="unique选项不是一个验证器"><a href="#unique选项不是一个验证器" class="headerlink" title="unique选项不是一个验证器"></a><code>unique</code>选项不是一个验证器</h3><p><code>unique</code>选项不是一个验证器，它用于快速建立MongoDB的unique indexes。更多信息查看<a href="http://mongoosejs.com/docs/faq.html" target="_blank" rel="noopener">FAQ</a>。</p><pre><code>  var uniqueUsernameSchema = new Schema({    username: {        type: String,        unique: true    }});var U1 = db.model(&apos;U1&apos;, uniqueUsernameSchema);var U2 = db.model(&apos;U2&apos;, uniqueUsernameSchema);var dup = [{ username: &apos;Val&apos; }, { username: &apos;Val&apos; }];U1.create(dup, function(error) {  // Race condition! This may save successfully, depending on whether  // MongoDB built the index before writing the 2 docs.});// Need to wait for the index to finish building before saving,// otherwise unique constraints may be violated.U2.once(&apos;index&apos;, function(error) {  assert.ifError(error);  U2.create(dup, function(error) {    // Will error, but will *not* be a mongoose validation error, it will be    // a duplicate key error.    assert.ok(error);    assert.ok(!error.errors);    assert.ok(error.message.indexOf(&apos;duplicate key error&apos;) !== -1);  });});// There&apos;s also a promise-based equivalent to the event emitter API.// The `init()` function is idempotent and returns a promise that// will resolve once indexes are done building;U2.init().then(function() {  U2.create(dup, function(error) {    // Will error, but will *not* be a mongoose validation error, it will be    // a duplicate key error.    assert.ok(error);    assert.ok(!error.errors);    assert.ok(error.message.indexOf(&apos;duplicate key error&apos;) !== -1);  });});</code></pre><h3 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a>自定义验证器</h3><p>如果内置的验证器满足不了你的需求，你可以使用自定义验证器。</p><p>通过传递一个validation函数实现自定义，具体细节查看<code>SchemaType#validate()</code>章节<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate" target="_blank" rel="noopener">API</a>文档</p><pre><code> var userSchema = new Schema({  phone: {    type: String,    validate: {      validator: function(v) {        return /\d{3}-\d{3}-\d{4}/.test(v);      },      message: &apos;{VALUE} is not a valid phone number!&apos;    },    required: [true, &apos;User phone number required&apos;]  }});var User = db.model(&apos;user&apos;, userSchema);var user = new User();var error;user.phone = &apos;555.0123&apos;;error = user.validateSync();assert.equal(error.errors[&apos;phone&apos;].message,  &apos;555.0123 is not a valid phone number!&apos;);user.phone = &apos;&apos;;error = user.validateSync();assert.equal(error.errors[&apos;phone&apos;].message,  &apos;User phone number required&apos;);user.phone = &apos;201-555-0123&apos;;// Validation succeeds! Phone number is defined// and fits `DDD-DDD-DDDD`error = user.validateSync();assert.equal(error, null);</code></pre><h3 id="自定义异步验证器"><a href="#自定义异步验证器" class="headerlink" title="自定义异步验证器"></a>自定义异步验证器</h3><p>我们也可以自定义异步验证器。如果验证器函数返回一个promise实例（像一个async函数）,mongoose会等待promise状态确定。如果你更喜欢callbacks形式，设置<code>isAsync</code>选项并且给验证器函数传入callback作为第二个参数。</p><pre><code> var userSchema = new Schema({  name: {    type: String,    // You can also make a validator async by returning a promise. If you    // return a promise, do **not** specify the `isAsync` option.    validate: function(v) {      return new Promise(function(resolve, reject) {        setTimeout(function() {          resolve(false);        }, 5);      });    }  },  phone: {    type: String,    validate: {      isAsync: true,      validator: function(v, cb) {        setTimeout(function() {          var phoneRegex = /\d{3}-\d{3}-\d{4}/;          var msg = v + &apos; is not a valid phone number!&apos;;          // First argument is a boolean, whether validator succeeded          // 2nd argument is an optional error message override          cb(phoneRegex.test(v), msg);        }, 5);      },      // Default error message, overridden by 2nd argument to `cb()` above      message: &apos;Default error message&apos;    },    required: [true, &apos;User phone number required&apos;]  }});var User = db.model(&apos;User&apos;, userSchema);var user = new User();var error;user.phone = &apos;555.0123&apos;;user.name = &apos;test&apos;;user.validate(function(error) {  assert.ok(error);  assert.equal(error.errors[&apos;phone&apos;].message,    &apos;555.0123 is not a valid phone number!&apos;);  assert.equal(error.errors[&apos;name&apos;].message,    &apos;Validator failed for path `name` with value `test`&apos;);});</code></pre><h3 id="错误验证"><a href="#错误验证" class="headerlink" title="错误验证"></a>错误验证</h3><p>如果验证失败会返回错误包含了一个错误对象，值为<code>ValidatorError</code>对象。<a href="http://mongoosejs.com/docs/api.html#error-validation-js" target="_blank" rel="noopener">ValidatorError</a>对象有<code>kind</code>、<code>path</code>、<code>value</code>和<code>message</code>等属性。验证器也可能有<code>reason</code>属性，如果执行验证器时发生了错误，<code>reason</code>属性包含抛出的错误。</p><pre><code> var toySchema = new Schema({  color: String,  name: String});var validator = function(value) {  return /red|white|gold/i.test(value);};toySchema.path(&apos;color&apos;).validate(validator,  &apos;Color `{VALUE}` not valid&apos;, &apos;Invalid color&apos;);toySchema.path(&apos;name&apos;).validate(function(v) {  if (v !== &apos;Turbo Man&apos;) {    throw new Error(&apos;Need to get a Turbo Man for Christmas&apos;);  }  return true;}, &apos;Name `{VALUE}` is not valid&apos;);var Toy = db.model(&apos;Toy&apos;, toySchema);var toy = new Toy({ color: &apos;Green&apos;, name: &apos;Power Ranger&apos; });toy.save(function (err) {  // `err` is a ValidationError object  // `err.errors.color` is a ValidatorError object  assert.equal(err.errors.color.message, &apos;Color `Green` not valid&apos;);  assert.equal(err.errors.color.kind, &apos;Invalid color&apos;);  assert.equal(err.errors.color.path, &apos;color&apos;);  assert.equal(err.errors.color.value, &apos;Green&apos;);  // This is new in mongoose 5. If your validator throws an exception,  // mongoose will use that message. If your validator returns `false`,  // mongoose will use the &apos;Name `Power Ranger` is not valid&apos; message.  assert.equal(err.errors.name.message,    &apos;Need to get a Turbo Man for Christmas&apos;);  assert.equal(err.errors.name.value, &apos;Power Ranger&apos;);  // If your validator threw an error, the `reason` property will contain  // the original error thrown, including the original stack trace.  assert.equal(err.errors.name.reason.message,    &apos;Need to get a Turbo Man for Christmas&apos;);  assert.equal(err.name, &apos;ValidationError&apos;);});</code></pre><h3 id="对嵌套对象使用Required验证器"><a href="#对嵌套对象使用Required验证器" class="headerlink" title="对嵌套对象使用Required验证器"></a>对嵌套对象使用Required验证器</h3><p>对类型嵌套对象的属性进行验证是比较棘手的，因为嵌套对象不完全成熟的路径。</p><pre><code>var personSchema = new Schema({  name: {    first: String,    last: String  }});assert.throws(function() {  // This throws an error, because &apos;name&apos; isn&apos;t a full fledged path  personSchema.path(&apos;name&apos;).required(true);}, /Cannot.*&apos;required&apos;/);// To make a nested object required, use a single nested schemavar nameSchema = new Schema({  first: String,  last: String});personSchema = new Schema({  name: {    type: nameSchema,    required: true  }});var Person = db.model(&apos;Person&apos;, personSchema);var person = new Person();var error = person.validateSync();assert.ok(error.errors[&apos;name&apos;]);</code></pre><h3 id="更新验证器"><a href="#更新验证器" class="headerlink" title="更新验证器"></a>更新验证器</h3><p>上面实例中，你学习了document的验证。Mongoose也支持执行<code>update()</code>或<code>findOneAndUpdate()</code>时的更新验证。更新验证默认关闭。设置<code>runValidators</code>选项，开启<code>update()</code>或者<code>findOneAndUpdate()</code>的更新验证。请注意，更新验证之所以默认关闭，因为会有一些警告信息。</p><pre><code>var toySchema = new Schema({  color: String,  name: String});var Toy = db.model(&apos;Toys&apos;, toySchema);Toy.schema.path(&apos;color&apos;).validate(function (value) {  return /blue|green|white|red|orange|periwinkle/i.test(value);}, &apos;Invalid color&apos;);var opts = { runValidators: true };Toy.update({}, { color: &apos;bacon&apos; }, opts, function (err) {  assert.equal(err.errors.color.message,    &apos;Invalid color&apos;);});</code></pre><h3 id="更新验证器和this"><a href="#更新验证器和this" class="headerlink" title="更新验证器和this"></a>更新验证器和<code>this</code></h3><p>更新验证器和document validator会有些不同。下面示例中，color path的验证函数中this指向正在被验证的document。然而执行更新验证时，document可能不在服务器内存中更新，所以默认this未定义。</p><pre><code>var toySchema = new Schema({  color: String,  name: String});toySchema.path(&apos;color&apos;).validate(function(value) {  // When running in `validate()` or `validateSync()`, the  // validator can access the document using `this`.  // Does **not** work with update validators.  if (this.name.toLowerCase().indexOf(&apos;red&apos;) !== -1) {    return value !== &apos;red&apos;;  }  return true;});var Toy = db.model(&apos;ActionFigure&apos;, toySchema);var toy = new Toy({ color: &apos;red&apos;, name: &apos;Red Power Ranger&apos; });var error = toy.validateSync();assert.ok(error.errors[&apos;color&apos;]);var update = { color: &apos;red&apos;, name: &apos;Red Power Ranger&apos; };var opts = { runValidators: true };Toy.update({}, update, opts, function(error) {  // The update validator throws an error:  // &quot;TypeError: Cannot read property &apos;toLowerCase&apos; of undefined&quot;,  // because `this` is **not** the document being updated when using  // update validators  assert.ok(error);});</code></pre><h3 id="context选项"><a href="#context选项" class="headerlink" title="context选项"></a><code>context</code>选项</h3><p>设置context选项，使this值在更新验证时指向隐藏的query。</p><pre><code>var toySchema = new Schema({  color: String,  name: String});toySchema.path(&apos;color&apos;).validate(function(value) {  // When running in `validate()` or `validateSync()`, the  // validator can access the document using `this`.  // Does **not** work with update validators.  if (this.name.toLowerCase().indexOf(&apos;red&apos;) !== -1) {    return value !== &apos;red&apos;;  }  return true;});var Toy = db.model(&apos;ActionFigure&apos;, toySchema);var toy = new Toy({ color: &apos;red&apos;, name: &apos;Red Power Ranger&apos; });var error = toy.validateSync();assert.ok(error.errors[&apos;color&apos;]);var update = { color: &apos;red&apos;, name: &apos;Red Power Ranger&apos; };var opts = { runValidators: true };Toy.update({}, update, opts, function(error) {  // The update validator throws an error:  // &quot;TypeError: Cannot read property &apos;toLowerCase&apos; of undefined&quot;,  // because `this` is **not** the document being updated when using  // update validators  assert.ok(error);});</code></pre><h3 id="指定需要更新验证器的路径"><a href="#指定需要更新验证器的路径" class="headerlink" title="指定需要更新验证器的路径"></a>指定需要更新验证器的路径</h3><p>请注意一个非常重要的细节，只有在执行以下更新操作时，更新验证器才会运行：</p><ul><li><code>$set</code></li><li><code>$unset</code></li><li><code>$push(&gt;=4.8.0)</code></li><li><code>$addToSet(&gt;=4.8.0)</code></li><li><code>$pull(&gt;=4.12.0)</code></li><li><code>$pullAll(&gt;=4.12.0)</code></li></ul><p>下例中的更新不会检查<code>number</code>值，所以更新可以执行成功，因为<code>$inc</code>操作不会执行更新验证器。 <code>$push</code>、<code>$addToSet</code>、<code>$pull</code>和<code>$pullAll</code>等操作不会验证数组本身，只会单独的验证数组中的元素。</p><pre><code>var testSchema = new Schema({  number: { type: Number, max: 0 },  arr: [{ message: { type: String, maxlength: 10 } }]});// Update validators won&apos;t check this, so you can still `$push` 2 elements// onto the array, so long as they don&apos;t have a `message` that&apos;s too long.testSchema.path(&apos;arr&apos;).validate(function(v) {  return v.length &lt; 2;});var Test = db.model(&apos;Test&apos;, testSchema);var update = { $inc: { number: 1 } };var opts = { runValidators: true };Test.update({}, update, opts, function(error) {  // There will never be a validation error here  update = { $push: [{ message: &apos;hello&apos; }, { message: &apos;world&apos; }] };  Test.update({}, update, opts, function(error) {    // This will never error either even though the array will have at    // least 2 elements.  });});</code></pre><h3 id="push和-addToSet的更新验证"><a href="#push和-addToSet的更新验证" class="headerlink" title="$push和$addToSet的更新验证"></a><code>$push</code>和<code>$addToSet</code>的更新验证</h3><p>执行<code>$push</code>和<code>$addToSet</code>操作时，也会执行更新验证器。</p><pre><code>var testSchema = new Schema({  numbers: [{ type: Number, max: 0 }],  docs: [{    name: { type: String, required: true }  }]});var Test = db.model(&apos;TestPush&apos;, testSchema);var update = {  $push: {    numbers: 1,    docs: { name: null }  }};var opts = { runValidators: true };Test.update({}, update, opts, function(error) {  assert.ok(error.errors[&apos;numbers&apos;]);  assert.ok(error.errors[&apos;docs&apos;]);});</code></pre><h2 id="下一章-——-Middleware"><a href="#下一章-——-Middleware" class="headerlink" title="下一章 —— Middleware"></a>下一章 —— <a href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Middleware/">Middleware</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方原版：&lt;a href=&quot;http://mongoosejs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mongoosejs.com&lt;/a&gt;&lt;br&gt;引用请注明出处和转载请注明出处&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="mongoose" scheme="https://dreamflyingcat.github.io/tags/mongoose/"/>
    
      <category term="mongoDB" scheme="https://dreamflyingcat.github.io/tags/mongoDB/"/>
    
      <category term="node.js" scheme="https://dreamflyingcat.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>mongoose v5.0.12 中文API - Subdocuments</title>
    <link href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Subdocuments/"/>
    <id>https://dreamflyingcat.github.io/2018/04/09/mongoose-Subdocuments/</id>
    <published>2018-04-09T04:16:51.276Z</published>
    <updated>2018-04-09T05:57:59.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方原版：<a href="http://mongoosejs.com" target="_blank" rel="noopener">http://mongoosejs.com</a><br>引用请注明出处和转载请注明出处</p></blockquote><h2 id="Sub-Docs"><a href="#Sub-Docs" class="headerlink" title="Sub Docs"></a>Sub Docs</h2><p>SubDocuments是嵌套在其他documents中的documents，这意味着你可以在Schemas中嵌套Schemas。Mongoose支持两种不同形式的subdocuments：subdocuments数组和单独嵌套的subdocuments（mongoose版本大于等于4.2.0）。</p><pre><code>var childSchema = new Schema({ name: &apos;string&apos; });    var parentSchema = new Schema({    // Array of subdocuments    children: [childSchema],    // Single nested subdocuments. Caveat: single nested subdocs only work    // in mongoose &gt;= 4.2.0    child: childSchema});</code></pre><p>sub-document享有所有与普通document相同的特征。嵌套的Schemas也可以有[middleware][<a href="http://mongoosejs.com/docs/middleware.html]和自定义的[validation][]，逻辑和使用与顶层schemas相同。subdocument最大的不同是不能单独保存，当它们的顶层父document保存时它们才被保存。" target="_blank" rel="noopener">http://mongoosejs.com/docs/middleware.html]和自定义的[validation][]，逻辑和使用与顶层schemas相同。subdocument最大的不同是不能单独保存，当它们的顶层父document保存时它们才被保存。</a></p><pre><code>var Parent = mongoose.model(&apos;Parent&apos;, parentSchema);var parent = new Parent({ children: [{ name: &apos;Matt&apos; }, { name: &apos;Sarah&apos; }] })parent.children[0].name = &apos;Matthew&apos;;// `parent.children[0].save()` is a no-op, it triggers middleware but// does **not** actually save the subdocument. You need to save the parent// doc.parent.save(callback);</code></pre><p>Subdocuments也有类似于顶层documents的<code>save</code>和<code>validate</code>中间件。调用<code>save()</code>保存父级document会触发所有的subdocuments的<code>save()</code>和<code>validate()</code>。</p><pre><code>childSchema.pre(&apos;save&apos;, function (next) {    if (&apos;invalid&apos; == this.name) {        return next(new Error(&apos;#sadpanda&apos;));    }    next();    });    var parent = new Parent({ children: [{ name: &apos;invalid&apos; }] });    parent.save(function (err) {    console.log(err.message) // #sadpanda});</code></pre><p>Subdocuments的<code>pre(&#39;save&#39;)</code>和<code>pre(&#39;validate&#39;)</code>中间件会在顶层ducument的<code>pre(&#39;save&#39;)</code>之前和<code>pre(&#39;validate&#39;)</code>之后执行。这是因为validating是一种内置的中间件，会在<code>save()</code>之前执行。</p><pre><code>// Below code will print out 1-4 in ordervar childSchema = new mongoose.Schema({ name: &apos;string&apos; });childSchema.pre(&apos;validate&apos;, function(next) {    console.log(&apos;2&apos;);    next();});childSchema.pre(&apos;save&apos;, function(next) {    console.log(&apos;3&apos;);    next();});var parentSchema = new mongoose.Schema({child: childSchema,    });parentSchema.pre(&apos;validate&apos;, function(next) {    console.log(&apos;1&apos;);    next();});parentSchema.pre(&apos;save&apos;, function(next) {    console.log(&apos;4&apos;);    next();});</code></pre><h3 id="查找sub-document"><a href="#查找sub-document" class="headerlink" title="查找sub-document"></a>查找sub-document</h3><p>每个subdocument都有一个<code>_id</code>,DocumentArrays有特殊的 id 方法来通过_id来查找document。。</p><h3 id="向数组中追加sub-docs"><a href="#向数组中追加sub-docs" class="headerlink" title="向数组中追加sub-docs"></a>向数组中追加sub-docs</h3><p>mongoose数组方法如<a href="http://mongoosejs.com/docs/api.html#types_array_MongooseArray.push" target="_blank" rel="noopener">push</a>、<a href="http://mongoosejs.com/docs/api.html#types_array_MongooseArray.unshift" target="_blank" rel="noopener">unshift</a>、<a href="http://mongoosejs.com/docs/api.html#types_array_MongooseArray.addToSet" target="_blank" rel="noopener">addToSet</a>等将参数显式转换成恰当的类型。</p><pre><code>var Parent = mongoose.model(&apos;Parent&apos;);var parent = new Parent;// create a commentparent.children.push({ name: &apos;Liesl&apos; });var subdoc = parent.children[0];console.log(subdoc) // { _id: &apos;501d86090d371bab2c0341c5&apos;, name: &apos;Liesl&apos; }subdoc.isNew; // trueparent.save(function (err) {    if (err) return handleError(err)    console.log(&apos;Success!&apos;);});</code></pre><p>也可以通过MongooseArrays的[create][]方法直接创建sub-docs，无需添加的数组中。</p><pre><code>var newdoc = parent.children.create({ name: &apos;Aaron&apos; });</code></pre><h3 id="删除subdocs"><a href="#删除subdocs" class="headerlink" title="删除subdocs"></a>删除subdocs</h3><p>移除subdocuments可以使用<a href="http://mongoosejs.com/docs/api.html#types_array_MongooseArray.remove" target="_blank" rel="noopener">remove</a>方法，对于subdocument数组来说，该方法等同于使用<code>.pull()</code>，在单独嵌套的subdocument使用该方法，相当于设置subdocument为<code>null</code>。</p><pre><code>// Equivalent to `parent.children.pull(_id)`parent.children.id(_id).remove();// Equivalent to `parent.child = null`parent.child.remove();parent.save(function (err) {    if (err) return handleError(err);    console.log(&apos;the subdocs were removed&apos;);});</code></pre><h3 id="数组的交替声明语法"><a href="#数组的交替声明语法" class="headerlink" title="数组的交替声明语法"></a>数组的交替声明语法</h3><p>如果你在Schema中声明一个对象数组的属性，mongoose会自动的将对象字面量转换成Schema（如果你不需要访问的子文档schena的实例，你也可以通过简单传递一个对象字面量声明子文档）。</p><pre><code>var parentSchema = new Schema({    children: [{ name: &apos;string&apos; }]});// Equivalentvar parentSchema = new Schema({    children: [new Schema({ name: &apos;string&apos; })]});</code></pre><h2 id="下一章-——-Queries"><a href="#下一章-——-Queries" class="headerlink" title="下一章 —— Queries"></a>下一章 —— <a href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Queries/">Queries</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方原版：&lt;a href=&quot;http://mongoosejs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mongoosejs.com&lt;/a&gt;&lt;br&gt;引用请注明出处和转载请注明出处&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="mongoose" scheme="https://dreamflyingcat.github.io/tags/mongoose/"/>
    
      <category term="mongoDB" scheme="https://dreamflyingcat.github.io/tags/mongoDB/"/>
    
      <category term="node.js" scheme="https://dreamflyingcat.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>mongoose v5.0.12 中文API - SchemaTypes</title>
    <link href="https://dreamflyingcat.github.io/2018/04/09/mongoose-SchemaTypes/"/>
    <id>https://dreamflyingcat.github.io/2018/04/09/mongoose-SchemaTypes/</id>
    <published>2018-04-09T04:16:19.399Z</published>
    <updated>2018-04-09T05:57:51.100Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方原版：<a href="http://mongoosejs.com" target="_blank" rel="noopener">http://mongoosejs.com</a><br>引用请注明出处和转载请注明出处</p></blockquote><h3 id="SchemaTypes"><a href="#SchemaTypes" class="headerlink" title="SchemaTypes"></a>SchemaTypes</h3><p>SchemaTypes定义路径（path）的<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType-default" target="_blank" rel="noopener">dufaults</a>、<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate" target="_blank" rel="noopener">validation</a>、<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType-get" target="_blank" rel="noopener">getters</a>、<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType-set" target="_blank" rel="noopener">setters</a>及查询时默认选择的<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType-select" target="_blank" rel="noopener">field</a>等属性，还有Strings和Numbers的其他的一些特征。</p><p>下面是mongoose中可用的SchemaTypes：</p><ul><li>String</li><li>Number</li><li>Date</li><li>Buffer</li><li>Boolean</li><li>Mixed</li><li>Objectid</li><li>Array</li><li>Decimal128</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre><code>var schema = new Schema({  name:    String,  binary:  Buffer,  living:  Boolean,  updated: { type: Date, default: Date.now },  age:     { type: Number, min: 18, max: 65 },  mixed:   Schema.Types.Mixed,  _someId: Schema.Types.ObjectId,  decimal: Schema.Types.Decimal128,  array:      [],  ofString:   [String],  ofNumber:   [Number],  ofDates:    [Date],  ofBuffer:   [Buffer],  ofBoolean:  [Boolean],  ofMixed:    [Schema.Types.Mixed],  ofObjectId: [Schema.Types.ObjectId],  ofArrays:   [[]],  ofArrayOfNumbers: [[Number]],  nested: {    stuff: { type: String, lowercase: true, trim: true }  }})// example usevar Thing = mongoose.model(&apos;Thing&apos;, schema);var m = new Thing;m.name = &apos;Statue of Liberty&apos;;m.age = 125;m.updated = new Date;m.binary = new Buffer(0);m.living = false;m.mixed = { any: { thing: &apos;i want&apos; } };m.markModified(&apos;mixed&apos;);m._someId = new mongoose.Types.ObjectId;m.array.push(1);m.ofString.push(&quot;strings!&quot;);m.ofNumber.unshift(1,2,3,4);m.ofDates.addToSet(new Date);m.ofBuffer.pop();m.ofMixed = [1, [], &apos;three&apos;, { four: 5 }];m.nested.stuff = &apos;good&apos;;m.save(callback);</code></pre><h3 id="SchemaType选项设置"><a href="#SchemaType选项设置" class="headerlink" title="SchemaType选项设置"></a>SchemaType选项设置</h3><p>你可以直接使用可用的type类型来声明一个schema type或者使用一个包含type字段的对象</p><pre><code>var schema1 = new Schema({  test: String // `test` is a path of type String});var schema2 = new Schema({  test: { type: String } // `test` is a path of type string});</code></pre><p>除了type之外你还可以给path指定其他的一些属性，例如，你想要在保存字符串之前将它转化为小写。</p><pre><code>var schema2 = new Schema({  test: {    type: String,    lowercase: true // Always convert `test` to lowercase  }});</code></pre><p>只有string类型的字段可以设置<code>lowercase</code>属性。有些选项适用于所有的schema类型，有些只适用于指定的schema类型。</p><h4 id="适用于所有schema类型的选项"><a href="#适用于所有schema类型的选项" class="headerlink" title="适用于所有schema类型的选项"></a>适用于所有schema类型的选项</h4><ul><li>required：boolean或者function，如果值为true时可以为字段添加一个必须验证器；</li><li>default：任意值或者function，用于给path设置默认值，如果值是一个函数，其返回值作为path的默认值；</li><li>select：boolean，指明查询时选择的字段；</li><li>validate：function，为字段添加验证器函数；</li><li>get：function，使用Object.defineProperty为字段自定义getter函数;</li><li>set：function，使用Object.defineProperty为字段自定义setter函数;</li><li><p>alias：stirng，mongoose&gt;=4.10.0才可以使用，为给定的字段设置一个别名，通过<code>sets/gets</code>设置或获取值；</p><p> var numberSchema = new Schema({<br>   integerOnly: {</p><pre><code>type: Number,get: v =&gt; Math.round(v),set: v =&gt; Math.round(v),alias: &apos;i&apos;</code></pre><p>   }<br> });</p><p> var Number = mongoose.model(‘Number’, numberSchema);</p><p> var doc = new Number();<br> doc.integerOnly = 2.001;<br> doc.integerOnly; // 2<br> doc.i; // 2<br> doc.i = 3.001;<br> doc.integerOnly; // 3<br> doc.i; // 3</p></li></ul><h4 id="indexes"><a href="#indexes" class="headerlink" title="indexes"></a>indexes</h4><p>可以通过设置schema类型的选项来定义mongoDB的索引；</p><ul><li>index：boolean，是否在该字段上建立索引（建立索引加快搜索速度，拖慢更新速度，因为更新数据时索引也要更新）；</li><li>unique：boolean，是否在该字段上定义唯一的索引；</li><li><p>sparse：boolean，是否在该字段上建立稀疏索引（稀疏索引会跳过键值不存在的文档）。</p><p> var schema2 = new Schema({<br> test: {<br>   type: String,<br>   index: true,<br>   unique: true // Unique index. If you specify <code>unique: true</code><br>   // specifying <code>index: true</code> is optional if you do <code>unique: true</code><br> }<br> });</p></li></ul><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul><li>lowercase：boolean，是否总是调用toLowerCase()函数将字段值转为小写；</li><li>uppercase：boolean，是否总是调用toUpperCase()函数将字段值转为大写；</li><li>trim：boolean，是否总是调用trim()去掉字段值中的空格；</li><li>match：RegExp，创建一个验证器检查字段值是否符合给出的正则表达式；</li><li>enum：Array，一个验证器用于检查字段值是否在给定的数组中。</li></ul><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><ul><li>min：Number，创建一个验证器用于检查字段值是否大于或等于给定的最小值；</li><li>max：Number，创建一个验证器用于检查字段值是否小于或等于给定的最大值。</li></ul><h4 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h4><ul><li>min：Date（日期需大于等于min值）；</li><li>max：Date（日期需小于等于max值）。</li></ul><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><p>Date对象内置的方法并没有和Mongoose关联起来，这意味着如果你调用Date的方法修改Document的Date类型值并保存并不会起作用，因为mongoose意识不到Date值变了，所以<code>doc.save()</code>无法保存修改。如果你必须使用内置的方法修改Date类型的值，保存前请调用<code>doc.marckModified(&#39;pathToYourDate&#39;)</code>通知mongoose此更改。</p><pre><code>var Assignment = mongoose.model(&apos;Assignment&apos;, { dueDate: Date });Assignment.findOne(function (err, doc) {  doc.dueDate.setMonth(3);  doc.save(callback); // THIS DOES NOT SAVE YOUR CHANGE  doc.markModified(&apos;dueDate&apos;);  doc.save(callback); // works})</code></pre><h4 id="Mixed"><a href="#Mixed" class="headerlink" title="Mixed"></a>Mixed</h4><p>Mixed类型接受任意类型的值，该类型虽然很灵活但是却难以维护，在schema中可以定义Mixed类型的字段。下面的几种方法是等价的，都可以声明字段为Mixed类型。</p><pre><code>var Any = new Schema({ any: {} });var Any = new Schema({ any: Object });var Any = new Schema({ any: Schema.Types.Mixed });</code></pre><p>Mixed属于chema-less类型的一种，你可以改变值为任意你想要的类型，但是mongoose失去了自动检测值的修改并保存修改的能力。如果你修改了Mixed类型的值，需要调用<code>doc.markModified(path)</code>方法通知mongoose该修改。</p><pre><code>person.anything = { x: [3, 4, { y: &quot;changed&quot; }] };person.markModified(&apos;anything&apos;);person.save(); // anything will now get saved</code></pre><h4 id="ObjectIds"><a href="#ObjectIds" class="headerlink" title="ObjectIds"></a>ObjectIds</h4><p>声明字段时，设置类型为<code>Schema.Types.ObjectId</code>，指定值为ObjectId的一种类型。</p><pre><code>var mongoose = require(&apos;mongoose&apos;);var ObjectId = mongoose.Schema.Types.ObjectId;var Car = new Schema({ driver: ObjectId });// or just Schema.ObjectId for backwards compatibility with v2</code></pre><h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p>设置字段值类型为<a href="http://mongoosejs.com/docs/api.html#schema_Schema.Types" target="_blank" rel="noopener">SchemaTypes</a>或者<a href="http://mongoosejs.com/docs/subdocs.html" target="_blank" rel="noopener">Sub-Documents</a>类型的数组。</p><pre><code>var ToySchema = new Schema({ name: String });var ToyBox = new Schema({  toys: [ToySchema],  buffers: [Buffer],  string:  [String],  numbers: [Number]  // ... etc});</code></pre><blockquote><p>注意：如果数组为空等价于<code>Mixed</code>类型，下列方法均创建元素为<code>Mixed</code>类型的数组。</p></blockquote><pre><code>var Empty1 = new Schema({ any: [] });var Empty2 = new Schema({ any: Array });var Empty3 = new Schema({ any: [Schema.Types.Mixed] });var Empty4 = new Schema({ any: [{}] });</code></pre><p>设置默认值为<code>undefined</code>重写默认情况</p><pre><code>var ToySchema = new Schema({  toys: {    type: [ToySchema],    default: undefined  }});</code></pre><h3 id="创建自定义的类型"><a href="#创建自定义的类型" class="headerlink" title="创建自定义的类型"></a>创建自定义的类型</h3><p>mongoose支持<a href="http://plugins.mongoosejs.io/" target="_blank" rel="noopener">plugins</a>扩展自定义schemaTypes，查看<a href="http://plugins.mongoosejs.io/" target="_blank" rel="noopener">plugins</a>网站查看可用的类型，例如<a href="https://github.com/aheckmann/mongoose-long" target="_blank" rel="noopener">mongoose-long</a>、<a href="https://github.com/vkarpov15/mongoose-int32" target="_blank" rel="noopener">mongoose-int32</a>还有其他的类型。</p><h4 id="schema-path-函数"><a href="#schema-path-函数" class="headerlink" title="schema.path()函数"></a><code>schema.path()</code>函数</h4><p><code>schema.path()</code>函数返回指定path的实例化的schema类型。</p><pre><code>var sampleSchema = new Schema({ name: { type: String, required: true } });console.log(sampleSchema.path(&apos;name&apos;));// Output looks like:/*** SchemaString {*   enumValues: [],*   regExp: null,*   path: &apos;name&apos;,*   instance: &apos;String&apos;,*   validators: ...*/</code></pre><p>可以使用该函数查看path的schema类型，包括验证器和字段的类型。</p><h2 id="下一章-——-Connections"><a href="#下一章-——-Connections" class="headerlink" title="下一章 —— Connections"></a>下一章 —— <a href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Connections/">Connections</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方原版：&lt;a href=&quot;http://mongoosejs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mongoosejs.com&lt;/a&gt;&lt;br&gt;引用请注明出处和转载请注明出处&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="mongoose" scheme="https://dreamflyingcat.github.io/tags/mongoose/"/>
    
      <category term="mongoDB" scheme="https://dreamflyingcat.github.io/tags/mongoDB/"/>
    
      <category term="node.js" scheme="https://dreamflyingcat.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>mongoose v5.0.12 中文API - Queries</title>
    <link href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Queries/"/>
    <id>https://dreamflyingcat.github.io/2018/04/09/mongoose-Queries/</id>
    <published>2018-04-09T04:15:10.054Z</published>
    <updated>2018-04-09T05:57:34.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方原版：<a href="http://mongoosejs.com" target="_blank" rel="noopener">http://mongoosejs.com</a><br>引用请注明出处和转载请注明出处</p></blockquote><h3 id="Queries"><a href="#Queries" class="headerlink" title="Queries"></a>Queries</h3><p>models提供了多个静态方法，用于检索Documents。任何涉及指定查询条件的models方法都能通过两个方法执行。根据是否传入回调函数，有以下两种情况：</p><ol><li>传入callback，操作将立即执行，结果传给回调函数；</li><li>不传callback，返回一个查询实例，它将提供一个特殊的查询生成接口。<br>对于第二种情况，Query实例对象有<code>.then()</code>方法，所以可以用作promise实例对象。</li></ol><p>执行查询时候传入callback回调函数，查询结果会以JSON格式返回。JSON文档的语法与<a href="http://docs.mongodb.org/manual/tutorial/query-documents/" target="_blank" rel="noopener">MongoDB shell</a>相同。</p><pre><code>var Person = mongoose.model(&apos;Person&apos;, yourSchema);// find each person with a last name matching &apos;Ghost&apos;, selecting the `name` and `occupation` fieldsPerson.findOne({ &apos;name.last&apos;: &apos;Ghost&apos; }, &apos;name occupation&apos;, function (err, person) {    if (err) return handleError(err);    // Prints &quot;Space Ghost is a talk show host&quot;.    console.log(&apos;%s %s is a %s.&apos;, person.name.first, person.name.last,person.occupation);});</code></pre><p>上例中，查询会被立即执行并将结果传入callback。Mongoose中所有的callbacks都遵循模式：<code>callback(error, result)</code>。如果查询时出错，<code>error</code>参数会包含一个错误对象且<code>result</code>为null。如果查询成功，<code>error</code>参数为null，<code>result</code>为查询结果。</p><p>Mongoose中任何情况下传入回调函数，都遵循<code>callback(error, results)</code>模式。查询结果取决于执行的操作：<code>findOne()</code>为可能为空的单document，<code>find()</code>为多个document，<code>count()</code>为document的个数，<code>update()</code>为受影响的document的数量。Model的<a href="http://mongoosejs.com/docs/api.html#model-js" target="_blank" rel="noopener">API</a>文档详细介绍了回调函数的可能结果。</p><p>现在看看在没有回调的情况下会发生什么：：</p><pre><code>// find each person with a last name matching &apos;Ghost&apos;var query = Person.findOne({ &apos;name.last&apos;: &apos;Ghost&apos; });// selecting the `name` and `occupation` fieldsquery.select(&apos;name occupation&apos;);// execute the query at a later timequery.exec(function (err, person) {    if (err) return handleError(err);    // Prints &quot;Space Ghost is a talk show host.&quot;    console.log(&apos;%s %s is a %s.&apos;, person.name.first, person.name.last,person.occupation);});</code></pre><p>上面代码中，<code>query</code>变量是Query的一种类型。<code>Query</code>允许你建立链式的查询语法，而不是指定JSON对象。下面两个例子是等价的：</p><pre><code>// With a JSON docPerson.   find({       occupation: /host/,       &apos;name.last&apos;: &apos;Ghost&apos;,       age: { $gt: 17, $lt: 66 },       likes: { $in: [&apos;vaporizing&apos;, &apos;talking&apos;] }   }).   limit(10).   sort({ occupation: -1 }).   select({ name: 1, occupation: 1 }).   exec(callback);// Using query builderPerson.   find({ occupation: /host/ }).   where(&apos;name.last&apos;).equals(&apos;Ghost&apos;).   where(&apos;age&apos;).gt(17).lt(66).   where(&apos;likes&apos;).in([&apos;vaporizing&apos;, &apos;talking&apos;]).   limit(10).   sort(&apos;-occupation&apos;).   select(&apos;name occupation&apos;).   exec(callback);</code></pre><p>可以在<a href="http://mongoosejs.com/docs/api.html#model-js" target="_blank" rel="noopener">API</a>文档中查看全部的Query辅助函数列表。</p><h3 id="引用其它的document"><a href="#引用其它的document" class="headerlink" title="引用其它的document"></a>引用其它的document</h3><p>MongoDB没有joins功能，但是有时我们想引用其它collections中的文档。这就是[population][]的由来。<a href="http://mongoosejs.com/docs/api.html#query_Query-populate" target="_blank" rel="noopener">查看</a>如何在查询结果中包含其他collection的document。</p><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>你可以流式从MongoDB中查询文档。调用<a href="http://mongoosejs.com/docs/api.html#querycursor-js" target="_blank" rel="noopener">Query#cursor()</a>会返回<a href="http://mongoosejs.com/docs/api.html#query_Query-cursor" target="_blank" rel="noopener">QueryCursor</a>实例。</p><h2 id="下一章-——-Validation"><a href="#下一章-——-Validation" class="headerlink" title="下一章 —— Validation"></a>下一章 —— <a href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Validation/">Validation</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方原版：&lt;a href=&quot;http://mongoosejs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mongoosejs.com&lt;/a&gt;&lt;br&gt;引用请注明出处和转载请注明出处&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="mongoose" scheme="https://dreamflyingcat.github.io/tags/mongoose/"/>
    
      <category term="mongoDB" scheme="https://dreamflyingcat.github.io/tags/mongoDB/"/>
    
      <category term="node.js" scheme="https://dreamflyingcat.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>mongoose v5.0.12 中文API - Models</title>
    <link href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Models/"/>
    <id>https://dreamflyingcat.github.io/2018/04/09/mongoose-Models/</id>
    <published>2018-04-09T04:14:21.995Z</published>
    <updated>2018-04-09T05:57:25.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方原版：<a href="http://mongoosejs.com" target="_blank" rel="noopener">http://mongoosejs.com</a><br>引用请注明出处和转载请注明出处</p></blockquote><h2 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h2><p>Modes是由Schema编译而成的假想（fancy）构造器，具有抽象属性和行为。Model的每一个实例（instance）就是一个document。document可以保存到数据库和从数据库返回。document的创建和搜索均可以通过操作model完成。</p><h3 id="定义你的第一个Model"><a href="#定义你的第一个Model" class="headerlink" title="定义你的第一个Model"></a>定义你的第一个Model</h3><pre><code>var schema = new mongoose.Schema({ name: &apos;string&apos;, size: &apos;string&apos; });var Tank = mongoose.model(&apos;Tank&apos;, schema);</code></pre><p>第一个参数是Model对应的collection名称的但是形式。因此，对于上面的实例，Tank model对应名称为tanks的collection。Model是由Schema编译生产的，在调用.model()之前，需要先定义好Schema。</p><h3 id="创建documents"><a href="#创建documents" class="headerlink" title="创建documents"></a>创建documents</h3><p>Documents是Model的实例，创建和保存document到数据库非常的简单：</p><pre><code>var Tank = mongoose.model(&apos;Tank&apos;, yourSchema);var small = new Tank({ size: &apos;small&apos; });small.save(function (err) {if (err) return handleError(err);// saved!})// orTank.create({ size: &apos;small&apos; }, function (err, small) {if (err) return handleError(err);// saved!})</code></pre><p>Document的创建和删除必须在mongoose connection建立之后才会执行。每一个model会关联一个connection，如果你使用<code>mongoose.model()</code>，创建的model会使用默认的mongoose connection。</p><pre><code>mongoose.connect(&apos;localhost&apos;, &apos;gettingstarted&apos;);</code></pre><p>如果你自定义了一个connection，可以使用该connection的<code>model()</code>函数。</p><pre><code>var connection = mongoose.createConnection(&apos;mongodb://localhost:27017/test&apos;);var Tank = connection.model(&apos;Tank&apos;, yourSchema);</code></pre><h3 id="Querying"><a href="#Querying" class="headerlink" title="Querying"></a>Querying</h3><p>Mongoose查询文档非常的便利，它提供非常丰富的MongoDB查询语法。可以使用models的<code>find</code>,<code>findById</code>,<code>findOne</code>,或者<code>where</code>等静态语法查询。</p><pre><code>Tank.find({ size: &apos;small&apos; }).where(&apos;createdDate&apos;).gt(oneYearAgo).exec(callback);</code></pre><p>更详细的Query api使用方法请查看<a href="http://mongoosejs.com/docs/api.html#Query" target="_blank" rel="noopener">querying</a>章节。</p><h3 id="Removing"><a href="#Removing" class="headerlink" title="Removing"></a>Removing</h3><p>Models提供<code>remove</code>静态方法用来移除所有符合提交的documents。</p><pre><code>Tank.remove({ size: &apos;large&apos; }, function (err) {    if (err) return handleError(err);    // removed!});</code></pre><h3 id="Updating"><a href="#Updating" class="headerlink" title="Updating"></a>Updating</h3><p>每个model都有自己的<code>update</code>方法用于修改数据库中的documents，并且该方法不会返回被修改的文档。更多详情可查看<a href="http://mongoosejs.com/docs/api.html#model_Model.update" target="_blank" rel="noopener">API</a>文档。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p><a href="http://mongoosejs.com/docs/api.html#model_Model" target="_blank" rel="noopener">API docs</a>还提供了很多其他的可用方法，例如<a href="http://mongoosejs.com/docs/api.html#model_Model.count" target="_blank" rel="noopener">count</a>, <a href="http://mongoosejs.com/docs/api.html#model_Model.mapReduce" target="_blank" rel="noopener">mapReduce</a>, <a href="http://mongoosejs.com/docs/api.html#model_Model.aggregate" target="_blank" rel="noopener">aggregate</a>, and <a href="http://mongoosejs.com/docs/api.html#model_Model.findOneAndRemove" target="_blank" rel="noopener">more</a>.</p><h2 id="下一章-——-Documents"><a href="#下一章-——-Documents" class="headerlink" title="下一章 —— Documents"></a>下一章 —— <a href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Documents/">Documents</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方原版：&lt;a href=&quot;http://mongoosejs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mongoosejs.com&lt;/a&gt;&lt;br&gt;引用请注明出处和转载请注明出处&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="mongoose" scheme="https://dreamflyingcat.github.io/tags/mongoose/"/>
    
      <category term="mongoDB" scheme="https://dreamflyingcat.github.io/tags/mongoDB/"/>
    
      <category term="node.js" scheme="https://dreamflyingcat.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>mongoose v5.0.12 中文API - Documents</title>
    <link href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Documents/"/>
    <id>https://dreamflyingcat.github.io/2018/04/09/mongoose-Documents/</id>
    <published>2018-04-09T04:13:15.282Z</published>
    <updated>2018-04-09T05:57:14.526Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方原版：<a href="http://mongoosejs.com" target="_blank" rel="noopener">http://mongoosejs.com</a><br>引用请注明出处和转载请注明出处</p></blockquote><h2 id="Documents"><a href="#Documents" class="headerlink" title="Documents"></a>Documents</h2><p>Mongoose <a href="http://mongoosejs.com/docs/api.html#document-js" target="_blank" rel="noopener">documents</a>和数据库中存储的document一一对应。每一个document都是它的Model的实例。</p><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><p>Mongoose提供了丰富的方法，从MongoDB中检索document，详情请查看[querying][]章节。</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>有很多的方法可以更新documents，我们首先了解传统的方法<code>findById</code>：</p><pre><code>Tank.findById(id, function (err, tank) {    if (err) return handleError(err);    tank.size = &apos;large&apos;;    tank.save(function (err, updatedTank) {        if (err) return handleError(err);        res.send(updatedTank);    });});</code></pre><p>你也可以使用<code>.set()</code>方法修改document。下例中，将<code>tank.size=&#39;large&#39;;</code>，修改为<code>tank.set({ size: &#39;large&#39; })</code>；</p><pre><code>Tank.findById(id, function (err, tank) {    if (err) return handleError(err);    tank.set({ size: &apos;large&apos; });    tank.save(function (err, updatedTank) {        if (err) return handleError(err);        res.send(updatedTank);    });});</code></pre><p>上面的方法首先从mongo中检索文档，然后发出修改命令（调用<code>save</code>触发）。如果我们的应用程序不需要返回document，只想直接修改数据库中的document，<a href="http://mongoosejs.com/docs/api.html#model_Model.update" target="_blank" rel="noopener">Model#update</a>更适合我们：</p><pre><code>Tank.update({ _id: id }, { $set: { size: &apos;large&apos; }}, callback);</code></pre><p>如果我们的应用程序想要返回document，我们最好使用下面的方法会：</p><pre><code>Tank.findByIdAndUpdate(id, { $set: { size: &apos;large&apos; }}, { new: true }, function (err, tank) {    if (err) return handleError(err);    res.send(tank);});</code></pre><p><code>findAndUpdate/Remove</code>静态方法最多只修改一个document，可以只调用一次就完成数据库中数据的修改，<a href="https://docs.mongodb.com/manual/reference/command/findAndModify/" target="_blank" rel="noopener">findAndModify</a>`主体有多种不同的使用方法，详情查看<a href="http://mongoosejs.com/docs/api.html" target="_blank" rel="noopener">API</a>文档。</p><p>请注意<code>findAndUpdate/Remove</code>修改documents之前并不会执行任何的hooks或者validation。你可以在该函数的option参数中设置<code>runValidators</code>属性为<code>true</code>开启本次更新的documents子集的验证。然而，如果你需要hooks和全部document validation，首先需要查询document，然后再<code>save()</code>它们。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>关于Documents保存之前的验证，详情请查看<a href="http://mongoosejs.com/docs/api.html" target="_blank" rel="noopener">API</a>文档或者<a href="http://mongoosejs.com/docs/validation.html" target="_blank" rel="noopener">validation</a>章节。</p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>你可以通过<code>.set()</code>方法重写document。该方法修改数据库中保存的文档非常的方便。</p><pre><code>Tank.findById(id, function (err, tank) {    if (err) return handleError(err);    // Now `otherTank` is a copy of `tank`    otherTank.set(tank);});</code></pre><h2 id="下一章-——-Subdocuments"><a href="#下一章-——-Subdocuments" class="headerlink" title="下一章 —— Subdocuments"></a>下一章 —— <a href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Subdocuments/">Subdocuments</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方原版：&lt;a href=&quot;http://mongoosejs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mongoosejs.com&lt;/a&gt;&lt;br&gt;引用请注明出处和转载请注明出处&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="mongoose" scheme="https://dreamflyingcat.github.io/tags/mongoose/"/>
    
      <category term="mongoDB" scheme="https://dreamflyingcat.github.io/tags/mongoDB/"/>
    
      <category term="node.js" scheme="https://dreamflyingcat.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>mongoose v5.0.12 中文API - Connections</title>
    <link href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Connections/"/>
    <id>https://dreamflyingcat.github.io/2018/04/09/mongoose-Connections/</id>
    <published>2018-04-09T04:12:24.649Z</published>
    <updated>2018-04-09T05:56:13.376Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方原版：<a href="http://mongoosejs.com" target="_blank" rel="noopener">http://mongoosejs.com</a><br>引用请注明出处和转载请注明出处</p></blockquote><h3 id="Connections"><a href="#Connections" class="headerlink" title="Connections"></a>Connections</h3><p>你可以使用<code>mongoose.connect()</code>方法连接mongoDB数据库。</p><pre><code>mongoose.connect(&apos;mongodb://localhost/myapp&apos;);</code></pre><p>这是连接运行在本地的Mongodb服务上（默认使用27017端口）的myapp数据库所需要的最少的参数，如果连接失败尝试修改localhost为127.0.0.1再试试，可能是因为改变了localhost的值导致了连接失败。</p><p>你可以在uri中指定更多的参数：</p><pre><code>mongoose.connect(&apos;mongodb://username:password@host:port/database?options...&apos;);</code></pre><p><a href="http://docs.mongodb.org/manual/reference/connection-string/" target="_blank" rel="noopener">点击查看</a>更多入参详情。</p><h3 id="缓冲操作"><a href="#缓冲操作" class="headerlink" title="缓冲操作"></a>缓冲操作</h3><p>你可以在mongoose连接到mongoDB之前就使用model操作数据库：</p><pre><code>nongoose.connect(&apos;mongodb://localhost/myapp&apos;);var MyModel = mongoose.model(&apos;Test&apos;, new Schema({ name: String }));// WorksMyModel.findOne(function(error, result) { /* ... */ });</code></pre><p>因为mongoose内部调用了缓冲模型函数，这种缓冲很方便，但也是常见的混乱来源。如果你在连接mongoDB之前调用models，mongoose默认不会抛出任何的错误。</p><pre><code>var MyModel = mongoose.model(&apos;Test&apos;, new Schema({ name: String }));// Will just hang until mongoose successfully connectsMyModel.findOne(function(error, result) { /* ... */ });setTimeout(function() {     mongoose.connect(&apos;mongodb://localhost/myapp&apos;);}, 60000);</code></pre><p>可以在你的<a href="http://mongoosejs.com/docs/guide.html#bufferCommands" target="_blank" rel="noopener">schema</a>中传入<code>bufferCommands</code>选项禁用缓冲。如果你开启了缓冲而且你的连接挂掉了，可以尝试关闭缓冲然后查看你是否正确的建立了连接。也可以全局关闭缓冲：</p><pre><code>mongoose.set(&apos;bufferCommands&apos;, false);</code></pre><h4 id="选项-Options"><a href="#选项-Options" class="headerlink" title="选项(Options)"></a>选项(Options)</h4><p>Mongoose的<code>connect</code>方法第二个参数为<code>options</code>对象，该对象会被传递给底层驱动程序，选项中的设置优先于连接字符串中传递的选项。</p><pre><code>mongoose.connect(uri, options);</code></pre><p><code>connect()</code>的参数——options的完整的选项列表可以点击<a href="http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html#connect" target="_blank" rel="noopener">mongoDB node驱动文档</a>查看。除了下面的例外情况，mongoose会将options中的选项原封不动的传递给驱动。</p><ul><li>bufferCommands – 是否开启mongoose的buffering, 该属性并不会传递给MongoDB底层驱动。</li><li>user/pass – 用于验证的用户名和密码。这两个选项为mongoose专用的，对应mongoDB驱动的auth.user和auth.password属性。</li><li>autoIndex – mongoose默认在建立连接时为schema中定义index的字段自动创建索引，该特性虽然有利于开发，但是对性能有很大的影响，不利于大型项目生产部署。设置autoIndex为false，mongoose会禁用自动创建索引功能。</li><li>dbName – 在连接字符串中指明连接和重写的数据库名称。如果你使用<code>mongodb+srv</code>语法连接<a href="https://www.mongodb.com/cloud/atlas" target="_blank" rel="noopener"> MongoDB Atlas</a>，需要使用<code>dbname</code>选项指明连接的数据库，因为在连接字符串中无法指明。</li></ul><p>下面的选项对于mongoose的调试（tuning mongoose不知道如何翻译，望高人指点）非常重要：</p><ul><li><code>autoReconnect</code> - 连接断开时候底层的MongoDB驱动会自动尝试重新连接，除非你是想要管理自己的连接池的非常高级的用户，否则请勿将此选项设置为<code>false</code>。</li><li><code>reconnectTries</code> - 如果到单个服务器或mongos代理（而不是副本集）的连接断开，MongoDB驱动程序将每隔reconnectInterval时间尝试重连，直到reconnectTries后放弃尝试，然后mongoose连接将触发reconnectFailed事件。 此选项对副本集连接不起任何作用。</li><li><code>reconnectInterval</code> - 详情查看reconnectTries。</li><li><code>promiseLibrary</code> - 设置底层驱动的<a href="http://mongodb.github.io/node-mongodb-native/2.1/api/MongoClient.html" target="_blank" rel="noopener">promise library</a><br>poolSize - MongoDB驱动程序为此连接保持打开的最大套接字数量。poolSize默认为5.请记住，从MongoDB 3.4开始，MongoDB一次只允许每个套接字执行一个操作，因此如果你增加操作，可能会导致一些慢的操作阻塞速度更快的查询。</li><li><code>bufferMaxEntries</code> - 当驱动程序断开连接时，MongoDB驱动程序有自己的缓冲机制。如果你希望数据库操作在未连接时立即失败，请将此选项设置为0，并设置schema的<code>bufferCommands</code>为<code>false</code>，而不是等待重新连接。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><pre><code>const options = {    useMongoClient: true,    autoIndex: false, // Don&apos;t build indexes    reconnectTries: Number.MAX_VALUE, // Never stop trying to reconnect    reconnectInterval: 500, // Reconnect every 500ms    poolSize: 10, // Maintain up to 10 socket connections    // If not connected, return errors immediately rather than waiting for reconnect    bufferMaxEntries: 0};mongoose.connect(uri, options);</code></pre><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p><code>connect()</code>函数接受一个回调函数作为参数，返回一个<a href="http://mongoosejs.com/docs/promises.html" target="_blank" rel="noopener">promise</a>。</p><pre><code>mongoose.connect(uri, options, function(error) {// Check error in initial connection. There is no 2nd param to the callback.});// Or using promisesmongoose.connect(uri, options).then(    () =&gt; { /** ready to use. The `mongoose.connect()` promise resolves to undefined. */ },    err =&gt; { /** handle initial connection error */ });</code></pre><h3 id="连接字符串选项"><a href="#连接字符串选项" class="headerlink" title="连接字符串选项"></a>连接字符串选项</h3><p>您还可以在连接字符串中指明驱动选项用于URI查询的参数。这仅适用于传递给MongoDB驱动程序的选项。您不能在查询字符串中设置特定于Mongoose的选项，如bufferCommands。</p><pre><code>mongoose.connect(&apos;mongodb://localhost:27017/test?connectTimeoutMS=1000&amp;bufferCommands=false&apos;);// The above is equivalent to:mongoose.connect(&apos;mongodb://localhost:27017/test&apos;, {connectTimeoutMS: 1000// Note that mongoose will **not** pull `bufferCommands` from the query string});</code></pre><p>将选项放入查询字符串的缺点是查询字符串选项难以阅读。 优点是你只需要一个配置选项，即URI，而不需要独立的配置socketTimeoutMS，connectTimeoutMS等多个选项。最佳实践是在连接字符串中放置开发和生产之间可能不同的选项，如replicaSet或ssl， 应该保持不变的选项，如connectTimeoutMS或poolSize放在options的对象中。</p><p>MongoDB文档有支持的连接字符串选项的<a href="https://docs.mongodb.com/manual/reference/connection-string/" target="_blank" rel="noopener">完整列表</a>。</p><p>###keepAlive注意事项</p><p>对于长期运行的应用程序需要谨慎设置<code>keepAlive</code>的值（毫秒为单位）。如果不设置该参数，你可能隔三差五的看到<code>connection closed</code>的错误提示而且不知道原因。如果是这样，阅读完<a href="http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html" target="_blank" rel="noopener">此文</a>后，您可能会决定启用keepAlive：</p><pre><code>mongoose.connect(uri, { keepAlive: 120 });</code></pre><h3 id="副本集连接"><a href="#副本集连接" class="headerlink" title="副本集连接"></a>副本集连接</h3><p>要连接到副本集，请传入以逗号分隔的主机列表而不是单个主机。</p><pre><code>mongoose.connect(&apos;mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]&apos; [, options]);</code></pre><h3 id="支持多个multi-mongos"><a href="#支持多个multi-mongos" class="headerlink" title="支持多个multi-mongos"></a>支持多个multi-mongos</h3><p>在集群中您还可以连接到多个mongos实例以实现高性能。对于mongoose 5.x，连接多个mongos您不需要任何特殊的选项。</p><pre><code>// Connect to 2 mongos serversmongoose.connect(&apos;mongodb://mongosA:27501,mongosB:27501&apos;, cb);</code></pre><h3 id="多连接"><a href="#多连接" class="headerlink" title="多连接"></a>多连接</h3><p>目前为止我们学习了使用mongoose默认连接连接到mongoDB。有时我们需要打开多个到mongo的连接，每个连接的读写设置不同，也可能连接到不同的数据库。这种情况下，可以使用<code>mongoose.createConnection()</code>方法，它接受上面提到的所有选项，并给你返回一个新的连接。</p><pre><code>const conn = mongoose.createConnection(&apos;mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]&apos;, options);</code></pre><p>这个连接之后用于新建和检索模型。模型始终限定到其中的一个连接。</p><p>当您调用<code>mongoose.connect()</code>时，Mongoose会创建一个默认连接。您可以使用mongoose.connection访问默认连接。</p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>每个连接无论是使用<code>mongoose.connect</code>还是<code>mongoose.createConnection</code>创建的，都需要内部可配置的连接池支持，默认最大为5。可以使用连接选项调整池大小：</p><pre><code>// With object optionsmongoose.createConnection(uri, { poolSize: 4 });const uri = &apos;mongodb://localhost/test?poolSize=4&apos;;mongoose.createConnection(uri);</code></pre><h3 id="5-x版本改变的选项"><a href="#5-x版本改变的选项" class="headerlink" title="5.x版本改变的选项"></a>5.x版本改变的选项</h3><p>如果从4.x升级到5.x并且没有在4.x中使用<code>useMongoClient</code>选项，则可能会看到以下弃用警告：</p><pre><code>the server/replset/mongos options are deprecated, all their options are supported at the top level of the options object</code></pre><p> 在较早版本的MongoDB驱动程序中，您必须为服务器连接、副本集连接和mongos连接指定不同的选项： </p><pre><code>mongoose.connect(myUri, {server: {    socketOptions: {    socketTimeoutMS: 0,    keepAlive: true    },    reconnectTries: 30},replset: {    socketOptions: {    socketTimeoutMS: 0,    keepAlive: true    },    reconnectTries: 30},mongos: {    socketOptions: {    socketTimeoutMS: 0,    keepAlive: true    },    reconnectTries: 30}});</code></pre><p>在mongoose v5.x中，您可以在顶层声明这些选项，而无需额外的嵌套。 以下是<a href="http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html" target="_blank" rel="noopener">所有支持选项的列表</a>。</p><pre><code>// Equivalent to the above codemongoose.connect(myUri, {    socketTimeoutMS: 0,    keepAlive: true,    reconnectTries: 30});</code></pre><h2 id="下一章-——-Models"><a href="#下一章-——-Models" class="headerlink" title="下一章 —— Models"></a>下一章 —— <a href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Models/">Models</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方原版：&lt;a href=&quot;http://mongoosejs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mongoosejs.com&lt;/a&gt;&lt;br&gt;引用请注明出处和转载请注明出处&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="mongoose" scheme="https://dreamflyingcat.github.io/tags/mongoose/"/>
    
      <category term="mongoDB" scheme="https://dreamflyingcat.github.io/tags/mongoDB/"/>
    
      <category term="node.js" scheme="https://dreamflyingcat.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>mongoose v5.0.12 中文API - 纲要</title>
    <link href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Schema/"/>
    <id>https://dreamflyingcat.github.io/2018/04/09/mongoose-Schema/</id>
    <published>2018-04-09T04:09:45.965Z</published>
    <updated>2018-04-09T05:57:43.412Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方原版：<a href="http://mongoosejs.com" target="_blank" rel="noopener">http://mongoosejs.com</a><br>引用请注明出处和转载请注明出处</p></blockquote><h2 id="纲要"><a href="#纲要" class="headerlink" title="纲要"></a>纲要</h2><p>如果你还不了解Mongoose如何工作，请先阅读<a href="http://mongoosejs.com/docs/index.html" target="_blank" rel="noopener">quickstart</a>章节。如果你是从4.x版本迁移到5.x，请花点时间阅读<a href="https://github.com/Automattic/mongoose/blob/master/migrating_to_5.md" target="_blank" rel="noopener">迁移指南</a>。</p><h3 id="定义你的schema"><a href="#定义你的schema" class="headerlink" title="定义你的schema"></a>定义你的schema</h3><p>在mongoose中一切都是从schema开始的，schema会被映射为mongoDB中的collection，并且定义了collection中documents的形式。</p><pre><code>var mongoose = require(&apos;mongoose&apos;);var Schema = mongoose.Schema;var blogSchema = new Schema({    title:  String,    author: String,    body:   String,    comments: [{ body: String, date: Date }],    date: { type: Date, default: Date.now },    hidden: Boolean,    meta: {    votes: Number,    favs:  Number    }});</code></pre><p>如果你之后想额外的增加keys，可以使用<a href="http://mongoosejs.com/docs/api.html#schema_Schema-add" target="_blank" rel="noopener">Schema#add</a>方法。</p><p>在我们的blogSchema中每个key对应document中的一个字段并且有一个关联的<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType" target="_blank" rel="noopener">SchemaType</a>。例如，我们定义的<code>title</code>字段的<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType" target="_blank" rel="noopener">SchemaType</a>为String类型，<code>date</code>的<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType" target="_blank" rel="noopener">SchemaType</a>是Date类型。keys也可以定义为嵌套的objects，包含了进一步的键/类型的定义，例如上面的<code>meta</code>属性。</p><p>下面是允许的schemaTypes类型：</p><ul><li>String</li><li>Number</li><li>Date</li><li>Buffer</li><li>Boolean</li><li>Mixed</li><li>ObjectId</li><li>Array</li></ul><p>点击查看更多的<a href="http://mongoosejs.com/docs/api.html#schematype_SchemaType" target="_blank" rel="noopener">SchemaType</a>。</p><p>Schemas不仅定义了文档和其结构，还定义了model的<a href="http://mongoosejs.com/docs/guide.html#methods" target="_blank" rel="noopener">实例方法</a>、<a href="http://mongoosejs.com/docs/guide.html#statics" target="_blank" rel="noopener">静态方法</a>、<a href="http://mongoosejs.com/docs/guide.html#indexes" target="_blank" rel="noopener">复合索引</a>和属于文档<a href="http://mongoosejs.com/docs/middleware.html" target="_blank" rel="noopener">中间件</a>的生命周期钩子函数。</p><h3 id="创建一个model"><a href="#创建一个model" class="headerlink" title="创建一个model"></a>创建一个model</h3><p>我们需要将我们定义的<code>blogSchema</code>转换成一个model才能工作。我们将<code>blogSchema</code>传给<code>mongoose.model(modelName, schema)</code>;</p><pre><code>  var Blog = mongoose.model(&apos;Blog&apos;, blogSchema);// ready to go!</code></pre><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>document是<code>model</code>的实例。document有许多内置的实例方法，我们也可以自定义document的实例方法。</p><pre><code>// define a schemavar animalSchema = new Schema({ name: String, type: String });// assign a function to the &quot;methods&quot; object of our animalSchemaanimalSchema.methods.findSimilarTypes = function(cb) {    return this.model(&apos;Animal&apos;).find({ type: this.type }, cb);};</code></pre><p>现在所有的<code>animal</code>实例都拥有<code>findSimilarTypes</code>方法。</p><pre><code>var Animal = mongoose.model(&apos;Animal&apos;, animalSchema);var dog = new Animal({ type: &apos;dog&apos; });dog.findSimilarTypes(function(err, dogs) {    console.log(dogs); // woof});</code></pre><ul><li>重写默认的mongoose document方法可能导致无法预知的结果，详情请点击<a href="http://mongoosejs.com/docs/api.html#schema_Schema.reserved" target="_blank" rel="noopener">查看</a>。</li><li>不要使用箭头函数声明方法，因为箭头函数阻止绑定<code>this</code>，所以你的方法无法访问document，上例将无法正常工作。</li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在<code>model</code>上绑定静态方法也很简单，继续上面的<code>animalSchema</code>示例：</p><pre><code>// assign a function to the &quot;statics&quot; object of our animalSchemaanimalSchema.statics.findByName = function(name, cb) {    return this.find({ name: new RegExp(name, &apos;i&apos;) }, cb);};var Animal = mongoose.model(&apos;Animal&apos;, animalSchema);Animal.findByName(&apos;fido&apos;, function(err, animals) {    console.log(animals);});</code></pre><p>要使用箭头函数声明方法，因为箭头函数阻止绑定<code>this</code>，在上例中使用箭头函数将无法正常工作。</p><h3 id="查询助手"><a href="#查询助手" class="headerlink" title="查询助手"></a>查询助手</h3><p>你也可以像添加实例方法那样给mongoose的查询添加查询助手函数。查询助手方法可以帮你建立<a href="http://mongoosejs.com/docs/queries.html" target="_blank" rel="noopener">链式查询</a>模式。</p><pre><code>animalSchema.query.byName = function(name) {    return this.find({ name: new RegExp(name, &apos;i&apos;) });};var Animal = mongoose.model(&apos;Animal&apos;, animalSchema);Animal.find().byName(&apos;fido&apos;).exec(function(err, animals) {    console.log(animals);});</code></pre><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>MongoDB支持<a href="https://docs.mongodb.com/manual/indexes/" target="_blank" rel="noopener">secondary indexes</a> 。在mongoose中，我们可以在schema的path级别和schema级别上定义索引。复合索引只能在schema级别上定义。</p><pre><code>var animalSchema = new Schema({name: String,type: String,tags: { type: [String], index: true } // field level});animalSchema.index({ name: 1, type: -1 }); // schema level</code></pre><p>当应用程序启动时，mongoose会自动创建你在schema中定义的索引。mongoose为每个index顺序执行<code>createIndex</code>，当所有的<code>createIndex</code>执行成功或者发生错误时会触发model上的index事件。虽然这个特性有利于开发，但是建议在生成环境中关闭它，因为创建索引会对性能造成很大的影响。可以通过设置<code>autoIndex</code>选择值为false在schema级别上或者全局关闭自动创建索引。</p><pre><code>mongoose.connect(&apos;mongodb://user:pass@localhost:port/database&apos;, { autoIndex: false });// ormongoose.createConnection(&apos;mongodb://user:pass@localhost:port/database&apos;, { autoIndex: false });// oranimalSchema.set(&apos;autoIndex&apos;, false);// ornew Schema({..}, { autoIndex: false });</code></pre><p>当所有index创建成功或者发生错误时会触发model上的index事件。</p><pre><code>// Will cause an error because mongodb has an _id index by default that// is not sparseanimalSchema.index({ _id: 1 }, { sparse: true });var Animal = mongoose.model(&apos;Animal&apos;, animalSchema);Animal.on(&apos;index&apos;, function(error) {    // &quot;_id index cannot be sparse&quot;    console.log(error.message);});</code></pre><p>点击查看<a href="http://mongoosejs.com/docs/api.html#model_Model.ensureIndexes" target="_blank" rel="noopener">Model#ensureIndexes</a>方法。</p><h3 id="虚拟属性"><a href="#虚拟属性" class="headerlink" title="虚拟属性"></a>虚拟属性</h3><p>document的虚拟属性可以被访问和设置，但是不会被存储到MongoDB中。getters用于格式化和组合字段，setter用于将一个值结构到数据库中的多个字段上。</p><pre><code>// define a schemavar personSchema = new Schema({    name: {    first: String,    last: String    }});// compile our modelvar Person = mongoose.model(&apos;Person&apos;, personSchema);// create a documentvar axl = new Person({    name: { first: &apos;Axl&apos;, last: &apos;Rose&apos; }});</code></pre><p>假设你想输出一个人的全名，你需要这样做：</p><pre><code>console.log(axl.name.first + &apos; &apos; + axl.name.last); // Axl Rose</code></pre><p>每次都要连接first name和last name是很麻烦的事情。如果你想要对name做些其他的处理，例如移除符号该怎么办呢？你可以定义一个<code>fullname</code>的虚拟属性的getter，该值不会被保存到MongoDB中。</p><pre><code>personSchema.virtual(&apos;fullName&apos;).get(function () {    return this.name.first + &apos; &apos; + this.name.last;});</code></pre><p>现在你可以调用getter函数获取<code>fullName</code>字段的值：</p><pre><code>console.log(axl.fullName); // Axl Rose</code></pre><p>mongoose不会输出虚拟的字段，当你使用<code>toJSON()</code>或者<code>toObject()</code>函数时（或者对document使用<code>JSON.stringify()</code>），可以给<code>toJSON()</code>或者<a href="http://mongoosejs.com/docs/api.html#document_Document-toObject" target="_blank" rel="noopener">toObject()</a><code>传</code>{ virtuals: true }`获取虚拟字段。</p><p>你可以自定义虚拟字段的setter函数，通过虚拟的<code>fullName</code>字段一次性设置first name和last name的值。</p><pre><code>personSchema.virtual(&apos;fullName&apos;).get(function() { return this.name.first + &apos; &apos; + this.name.last; }).set(function(v) {    this.name.first = v.substr(0, v.indexOf(&apos; &apos;));    this.name.last = v.substr(v.indexOf(&apos; &apos;) + 1);});axl.fullName = &apos;William Rose&apos;; // Now `axl.name.first` is &quot;William&quot;</code></pre><p>虚拟字段的setters会在其他的validation之前运行。所以即使<code>first</code>和<code>last</code>字段值必须，上例依然会执行。</p><p>只有非虚拟字段可以用于查询和选择的字段，因为虚拟字段不会被存到MongoDB中，所以不能用于查询。</p><h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>别名属于特殊的虚拟字段，其getter和setter用于设置和获取另一个字段。为了节省带宽，你可以使用简短的字段名称用于存储到数据库，使用更长的语义化的别名提高代码可读性。</p><pre><code>var personSchema = new Schema({n: {    type: String,    // Now accessing `name` will get you the value of `n`, and setting `n` will set the value of `name`    alias: &apos;name&apos;}});// Setting `name` will propagate to `n`var person = new Person({ name: &apos;Val&apos; });console.log(person); // { n: &apos;Val&apos; }console.log(person.toObject({ virtuals: true })); // { n: &apos;Val&apos;, name: &apos;Val&apos; }console.log(person.name); // &quot;Val&quot;person.name = &apos;Not Val&apos;;console.log(person); // { n: &apos;Not Val&apos; }</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>schemas有一些可配置的选项可直接传递给构造器或者<code>set</code>：</p><pre><code>new Schema({..}, options);// orvar schema = new Schema({..});schema.set(option, value);</code></pre><p>有效的选项：</p><pre><code>* autoIndex* bufferCommands* capped* collection* id* _id* minimize* read* shardKey* strict* strictQuery* toJSON* toObject* typeKey* validateBeforeSave* versionKey* collation* skipVersioning* timeStamps</code></pre><h4 id="autoIndex"><a href="#autoIndex" class="headerlink" title="autoIndex"></a>autoIndex</h4><p>当应用程序启动时，mongoose会发出<code>createIndex</code>命令自动创建你在schema中定义的索引。mongoose v3版本索引默认在后台创建索引。如果你希望关闭自动创建选择手动创建索引时，设置<code>autoIndex</code>选择值为false，并调用model的<a href="http://mongoosejs.com/docs/api.html#model_Model.ensureIndexes" target="_blank" rel="noopener">ensureIndexes</a>方法。</p><pre><code>var schema = new Schema({..}, { autoIndex: false });var Clock = mongoose.model(&apos;Clock&apos;, schema);Clock.ensureIndexes(callback);</code></pre><h4 id="bufferCommands"><a href="#bufferCommands" class="headerlink" title="bufferCommands"></a>bufferCommands</h4><p>如果connection断掉，mongoose会默认缓冲命令，直到驱动重连才会执行命令。设置<code>bufferCommands</code>值为false关闭缓冲。</p><pre><code>var schema = new Schema({..}, { bufferCommands: false });</code></pre><p>设置schema的<code>bufferCommands</code>选项会重写全局的<code>bufferCommands</code>选项：</p><pre><code>mongoose.set(&apos;bufferCommands&apos;, true);// Schema option below overrides the above, if the schema option is set.var schema = new Schema({..}, { bufferCommands: false });</code></pre><h4 id="capped"><a href="#capped" class="headerlink" title="capped"></a>capped</h4><p>Mongoose支持设置MongoDB集合大小的上限值。设置<code>capped</code>属性限制MongoDB集合的最大值，单位bytes。</p><pre><code>new Schema({..}, { capped: 1024 });</code></pre><p>如果你想传其他的选项，例如max或者autoIndexId，可以将<code>capped</code>值设置为一个对象。这种情况下，<code>size</code>属性为必传值。</p><pre><code>new Schema({..}, { capped: { size: 1024, max: 1000, autoIndexId: true } });</code></pre><h4 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h4><p>Mongoose默认使用utils.tocollectionname方法生成集合的集合名称。该方法会生成复数形式的名称。如果你需要自定义集合名称，可以传入下面的选项。</p><pre><code>var dataSchema = new Schema({..}, { collection: &apos;data&apos; });</code></pre><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>mongoose默认为每一个schema分配一个虚拟的<code>id</code> getter，该方法返回document的<code>_id</code>字段，类型为string或者ObjectId（哈希字符串）。如果你的schema不需要<code>id</code> getter，给schema的构造函数传option禁用该功能。</p><pre><code>// default behaviorvar schema = new Schema({ name: String });var Page = mongoose.model(&apos;Page&apos;, schema);var p = new Page({ name: &apos;mongodb.org&apos; });console.log(p.id); // &apos;50341373e894ad16347efe01&apos;// disabled idvar schema = new Schema({ name: String }, { id: false });var Page = mongoose.model(&apos;Page&apos;, schema);var p = new Page({ name: &apos;mongodb.org&apos; });console.log(p.id); // undefined</code></pre><h4 id="id-1"><a href="#id-1" class="headerlink" title="_id"></a>_id</h4><p>如果没有禁用，mongoose默认为每一个schema分配<code>_id</code>字段，值为ObjectId类型，与MongoDB默认行为一致。如果你的schema不需要<code>id</code> getter，给schema的构造函数传option禁用该功能。</p><p>你只能在sub-document中使用此选项，因为如果没有<code>_id</code>，将document保存到数据库时会报错。</p><pre><code>// default behaviorvar schema = new Schema({ name: String });var Page = mongoose.model(&apos;Page&apos;, schema);var p = new Page({ name: &apos;mongodb.org&apos; });console.log(p); // { _id: &apos;50341373e894ad16347efe01&apos;, name: &apos;mongodb.org&apos; }// disabled _idvar childSchema = new Schema({ name: String }, { _id: false });var parentSchema = new Schema({ children: [childSchema] });var Model = mongoose.model(&apos;Model&apos;, parentSchema);Model.create({ children: [{ name: &apos;Luke&apos; }] }, function(error, doc) {// doc.children[0]._id will be undefined});</code></pre><h4 id="minimize"><a href="#minimize" class="headerlink" title="minimize"></a>minimize</h4><p>mongoose默认不存储空对象，实现schemas最小化。</p><pre><code>var schema = new Schema({ name: String, inventory: {} });var Character = mongoose.model(&apos;Character&apos;, schema);// will store `inventory` field if it is not emptyvar frodo = new Character({ name: &apos;Frodo&apos;, inventory: { ringOfPower: 1 }});Character.findOne({ name: &apos;Frodo&apos; }, function(err, character) {console.log(character); // { name: &apos;Frodo&apos;, inventory: { ringOfPower: 1 }}});// will not store `inventory` field if it is emptyvar sam = new Character({ name: &apos;Sam&apos;, inventory: {}});Character.findOne({ name: &apos;Sam&apos; }, function(err, character) {console.log(character); // { name: &apos;Sam&apos; }});</code></pre><p>设置<code>minimize</code>选项重写默认行为，下例中会存储空对象：</p><pre><code>var schema = new Schema({ name: String, inventory: {} }, { minimize: false });var Character = mongoose.model(&apos;Character&apos;, schema);// will store `inventory` if emptyvar sam = new Character({ name: &apos;Sam&apos;, inventory: {}});Character.findOne({ name: &apos;Sam&apos; }, function(err, character) {console.log(character); // { name: &apos;Sam&apos;, inventory: {}}});</code></pre><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>mongoose允许在schema级别设置<a href="http://mongoosejs.com/docs/api.html#query_Query-read" target="_blank" rel="noopener">查询＃读取</a>选项，为我们提供一种将默认ReadPreferences应用于从模型派生的所有查询的方法。</p><pre><code>var schema = new Schema({..}, { read: &apos;primary&apos; });            // also aliased as &apos;p&apos;var schema = new Schema({..}, { read: &apos;primaryPreferred&apos; });   // aliased as &apos;pp&apos;var schema = new Schema({..}, { read: &apos;secondary&apos; });          // aliased as &apos;s&apos;var schema = new Schema({..}, { read: &apos;secondaryPreferred&apos; }); // aliased as &apos;sp&apos;var schema = new Schema({..}, { read: &apos;nearest&apos; });            // aliased as &apos;n&apos;</code></pre><p>每个pref允许使用简单的别名，不必须使用全拼，例如’secondaryPreferred’，防止拼写错误。</p><p>读选项允许我们设置tag，指明驱动应该试图读取的replicaSet。更多<a href="https://docs.mongodb.com/manual/applications/replication/#tag-sets" target="_blank" rel="noopener">tag设置</a>详情点击查看。</p><blockquote><p>注意：你可以在连接数据库时，指明驱动的读选项的pref <a href="http://mongodb.github.io/node-mongodb-native/api-generated/replset.html?highlight=strategy" target="_blank" rel="noopener">strategy</a>。</p></blockquote><pre><code>// pings the replset members periodically to track network latencyvar options = { replset: { strategy: &apos;ping&apos; }};mongoose.connect(uri, options);var schema = new Schema({..}, { read: [&apos;nearest&apos;, { disk: &apos;ssd&apos; }] });mongoose.model(&apos;JellyBean&apos;, schema);</code></pre><h4 id="shardKey"><a href="#shardKey" class="headerlink" title="shardKey"></a>shardKey</h4><p>当我们有一个分片的MongoDB架构时，需要使用hardKey（片键）选项。每个分片集合都有一个分片键，它必须存在于所有插入/更新操作中。我们只需要在schema属性中配置shardKey。</p><pre><code>new Schema({ .. }, { shardKey: { tag: 1, name: 1 }})</code></pre><blockquote><p>请注意，Mongoose不会为你发送<code>shardcollection</code>命令。 你必须自己配置你的碎片。</p></blockquote><h4 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h4><p>mongoose默认开启strict模式，确保传递给model却没有在schema中声明的字段，不会被保存到数据库中。</p><pre><code>var thingSchema = new Schema({..})var Thing = mongoose.model(&apos;Thing&apos;, thingSchema);var thing = new Thing({ iAmNotInTheSchema: true });thing.save(); // iAmNotInTheSchema is not saved to the db// set to false..var thingSchema = new Schema({..}, { strict: false });var thing = new Thing({ iAmNotInTheSchema: true });thing.save(); // iAmNotInTheSchema is now saved to the db!!</code></pre><p>该选项也影响<code>doc.set()</code>执行的结果。</p><pre><code>var thingSchema = new Schema({..})var Thing = mongoose.model(&apos;Thing&apos;, thingSchema);var thing = new Thing;thing.set(&apos;iAmNotInTheSchema&apos;, true);thing.save(); // iAmNotInTheSchema is not saved to the db</code></pre><p>通过给model的实例传递第二个参数重写该选项。</p><pre><code>var Thing = mongoose.model(&apos;Thing&apos;);var thing = new Thing(doc, true);  // enables strict modevar thing = new Thing(doc, false); // disables strict mode</code></pre><p><code>strict</code>值也可以被设置为<code>throw</code>，如果保存坏数据到数据库会报错而不是忽略该数据。</p><blockquote><p>请注意，不设置schema的option时，model实例设置任何的未在schema中声明的key/val键值对都会被忽视。</p></blockquote><pre><code>var thingSchema = new Schema({..})var Thing = mongoose.model(&apos;Thing&apos;, thingSchema);var thing = new Thing;thing.iAmNotInTheSchema = true;thing.save(); // iAmNotInTheSchema is never saved to the db</code></pre><h4 id="strictQuery"><a href="#strictQuery" class="headerlink" title="strictQuery"></a>strictQuery</h4><p>为了向后兼容，<code>strict</code>选项在查询时不会用于过滤字段。</p><pre><code>const mySchema = new Schema({ field: Number }, { strict: true });const MyModel = mongoose.model(&apos;Test&apos;, mySchema);// Mongoose will **not** filter out `notInSchema: 1`, despite `strict: true`MyModel.find({ notInSchema: 1 });</code></pre><p><code>strict</code>选项也会用于更新数据。</p><pre><code>// Mongoose will strip out `notInSchema` from the update if `strict` is// not `false`MyModel.updateMany({}, { $set: { notInSchema: 1 } });</code></pre><p>mongoose提供了一个独立的选项<code>strictQuery</code>用于查询时过滤字段。</p><pre><code>const mySchema = new Schema({ field: Number }, {    strict: true,    strictQuery: true // Turn on strict mode for query filters});const MyModel = mongoose.model(&apos;Test&apos;, mySchema);// Mongoose will strip out `notInSchema: 1` because `strictQuery` is `true`MyModel.find({ notInSchema: 1 });</code></pre><h4 id="toJSON"><a href="#toJSON" class="headerlink" title="toJSON"></a>toJSON</h4><p>与<a href="http://mongoosejs.com/docs/guide.html#toObject" target="_blank" rel="noopener">toObject</a>选项相同，但是<code>toJSON</code>方法只能被documents调用</p><pre><code>var schema = new Schema({ name: String });schema.path(&apos;name&apos;).get(function (v) {return v + &apos; is my name&apos;;});schema.set(&apos;toJSON&apos;, { getters: true, virtuals: false });var M = mongoose.model(&apos;Person&apos;, schema);var m = new M({ name: &apos;Max Headroom&apos; });console.log(m.toObject()); // { _id: 504e0cd7dd992d9be2f20b6f, name: &apos;Max Headroom&apos; }console.log(m.toJSON()); // { _id: 504e0cd7dd992d9be2f20b6f, name: &apos;Max Headroom is my name&apos; }// since we know toJSON is called whenever a js object is stringified:console.log(JSON.stringify(m)); // { &quot;_id&quot;: &quot;504e0cd7dd992d9be2f20b6f&quot;, &quot;name&quot;: &quot;Max Headroom is my name&quot; }</code></pre><p><a href="http://mongoosejs.com/docs/api.html#document_Document-toObject" target="_blank" rel="noopener">点击查看</a>所有可用的<code>toJSON/toObject</code>选项。</p><h4 id="toObject"><a href="#toObject" class="headerlink" title="toObject"></a>toObject</h4><p>document可以调用<a href="http://mongoosejs.com/docs/guide.html#toObject" target="_blank" rel="noopener">toObject</a>方法将mongoose document转换为普通的JavaScript对象。该方法接受一些参数，我们可以声明这些选项并默认应用于所有的schema documents，而不是在每个文档的基础上应用这些选项。</p><p>想要在<code>console.log</code>中输出所有的虚拟字段，在<code>toObject</code>选项中设置<code>{ getters: true }</code>：</p><pre><code>var schema = new Schema({ name: String });schema.path(&apos;name&apos;).get(function (v) {return v + &apos; is my name&apos;;});schema.set(&apos;toObject&apos;, { getters: true });var M = mongoose.model(&apos;Person&apos;, schema);var m = new M({ name: &apos;Max Headroom&apos; });console.log(m); // { _id: 504e0cd7dd992d9be2f20b6f, name: &apos;Max Headroom is my name&apos; }</code></pre><p>点击查看<a href="http://mongoosejs.com/docs/api.html#document_Document-toObject" target="_blank" rel="noopener">这里</a>所有可用的<code>toObject</code>选项。</p><h4 id="typeKey"><a href="#typeKey" class="headerlink" title="typeKey"></a>typeKey</h4><p>如果schema中的object定义了’type’字段，mongoose默认把它理解为字段类型声明。</p><pre><code>// Mongoose interprets this as &apos;loc is a String&apos;var schema = new Schema({ loc: { type: String, coordinates: [Number] } });</code></pre><p>然而有些应用中例如<a href="https://docs.mongodb.com/manual/reference/geojson/" target="_blank" rel="noopener">geoJSON</a>，’type’属性是非常重要的，你可以设置’typeKey’选项来控制哪个字段用于声明字段类型。</p><pre><code>var schema = new Schema({// Mongoose interpets this as &apos;loc is an object with 2 keys, type and coordinates&apos;loc: { type: String, coordinates: [Number] },// Mongoose interprets this as &apos;name is a String&apos;name: { $type: String }}, { typeKey: &apos;$type&apos; }); // A &apos;$type&apos; key means this object is a type declaration</code></pre><h4 id="validateBeforeSave"><a href="#validateBeforeSave" class="headerlink" title="validateBeforeSave"></a>validateBeforeSave</h4><p>在document保存到数据库前会自动执行验证器，对于验证失败的文档会阻止保存。如果你想手动控制验证并且让验证失败的document也可以保存到数据库，可以设置<code>validateBeforeSave</code>值为false。</p><pre><code>var schema = new Schema({ name: String });schema.set(&apos;validateBeforeSave&apos;, false);schema.path(&apos;name&apos;).validate(function (value) {    return v != null;});var M = mongoose.model(&apos;Person&apos;, schema);var m = new M({ name: null });m.validate(function(err) {    console.log(err); // Will tell you that null is not allowed.});m.save(); // Succeeds despite being invalid</code></pre><h4 id="versionKey"><a href="#versionKey" class="headerlink" title="versionKey"></a>versionKey</h4><p>mongoose默认在第一次创建文档时为每个document设置<code>versionKey</code>。此值包含了document的内部修订版本号。<code>versionkey</code>选项是一个字符串，用于表示版本控制的路径，默认值为<code>_v</code>。如果与你的应用有冲突，你可以如下例中修改：</p><pre><code>var schema = new Schema({ name: &apos;string&apos; });var Thing = mongoose.model(&apos;Thing&apos;, schema);var thing = new Thing({ name: &apos;mongoose v3&apos; });thing.save(); // { __v: 0, name: &apos;mongoose v3&apos; }// customized versionKeynew Schema({..}, { versionKey: &apos;_somethingElse&apos; })var Thing = mongoose.model(&apos;Thing&apos;, schema);var thing = new Thing({ name: &apos;mongoose v3&apos; });thing.save(); // { _somethingElse: 0, name: &apos;mongoose v3&apos; }</code></pre><p>可以设置<code>versionKey</code>值为false，禁用document的版本号。不要禁用版本号除非<a href="http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning" target="_blank" rel="noopener">你知道你正在做什么</a>。</p><h4 id="collation"><a href="#collation" class="headerlink" title="collation"></a>collation</h4><p>为每个查询和聚合设置默认的<a href="https://docs.mongodb.com/manual/reference/collation/" target="_blank" rel="noopener">collation</a>。 这是一个初学者友好的<a href="https://docs.mongodb.com/manual/reference/collation/" target="_blank" rel="noopener">collation</a><a href="http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations" target="_blank" rel="noopener">collation总览</a>。</p><h4 id="skipVersioning"><a href="#skipVersioning" class="headerlink" title="skipVersioning"></a>skipVersioning</h4><p><code>skipversioning</code>允许阻止版本号更新（例如，内部版本号不会增加即使这些路径更新）。不要这样做，除非你知道你在做什么。对于子文档，使用完全限定的路径将版本号包含在父文档中。</p><pre><code>new Schema({..}, { skipVersioning: { dontVersionMe: true } });thing.dontVersionMe.push(&apos;hey&apos;);thing.save(); // version is not incremented</code></pre><h4 id="timestamps"><a href="#timestamps" class="headerlink" title="timestamps"></a>timestamps</h4><p>如果设置了<code>timestamps</code>，mongoose会为你的schema分配<code>createAt</code>和<code>updateAt</code>字段，值为<code>Date</code>类型。</p><p>默认情况下，两个字段的名称为<code>createAt</code>和<code>updateAt</code>，设置<code>timestamps.createdAt</code>和<code>timestamps.updatedAt</code>自定义字段名称。</p><pre><code>var thingSchema = new Schema({..}, { timestamps: { createdAt: &apos;created_at&apos; } });var Thing = mongoose.model(&apos;Thing&apos;, thingSchema);var thing = new Thing();thing.save(); // `created_at` &amp; `updatedAt` will be included</code></pre><h4 id="useNestedStrict"><a href="#useNestedStrict" class="headerlink" title="useNestedStrict"></a>useNestedStrict</h4><p>mongoose v4版本执行<code>update()</code>和<code>findOneAndUpdate()</code>操作时只会检查顶级schema的严格模式设置。</p><pre><code>var childSchema = new Schema({}, { strict: false });var parentSchema = new Schema({ child: childSchema }, { strict: &apos;throw&apos; });var Parent = mongoose.model(&apos;Parent&apos;, parentSchema);Parent.update({}, { &apos;child.name&apos;: &apos;Luke Skywalker&apos; }, function(error) {// Error because parentSchema has `strict: throw`, even though// `childSchema` has `strict: false`});var update = { &apos;child.name&apos;: &apos;Luke Skywalker&apos; };var opts = { strict: false };Parent.update({}, update, opts, function(error) {// This works because passing `strict: false` to `update()` overwrites// the parent schema.});</code></pre><p>如果你设置了<code>useNestedStrict</code>值为true，mongoose在执行updates时会使用child schema的<code>strict</code>选项的值。</p><pre><code>var childSchema = new Schema({}, { strict: false });var parentSchema = new Schema({ child: childSchema },{ strict: &apos;throw&apos;, useNestedStrict: false });var Parent = mongoose.model(&apos;Parent&apos;, parentSchema);Parent.update({}, { &apos;child.name&apos;: &apos;Luke Skywalker&apos; }, function(error) {// Works!});</code></pre><h4 id="Pluggable"><a href="#Pluggable" class="headerlink" title="Pluggable"></a>Pluggable</h4><p>schema允许使用<a href="http://mongoosejs.com/docs/plugins.html" target="_blank" rel="noopener">插件</a>，这样我们将有用的功能打包成插件，在社区或者项目中实现共享。</p><h2 id="下一章-——-SchemaTypes"><a href="#下一章-——-SchemaTypes" class="headerlink" title="下一章 —— SchemaTypes"></a>下一章 —— <a href="https://dreamflyingcat.github.io/2018/04/09/mongoose-SchemaTypes/">SchemaTypes</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方原版：&lt;a href=&quot;http://mongoosejs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mongoosejs.com&lt;/a&gt;&lt;br&gt;引用请注明出处和转载请注明出处&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="mongoose" scheme="https://dreamflyingcat.github.io/tags/mongoose/"/>
    
      <category term="mongoDB" scheme="https://dreamflyingcat.github.io/tags/mongoDB/"/>
    
      <category term="node.js" scheme="https://dreamflyingcat.github.io/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>中文转拼音或首字母模块</title>
    <link href="https://dreamflyingcat.github.io/2018/04/09/%E4%B8%AD%E6%96%87%E8%BD%AC%E6%8B%BC%E9%9F%B3%E6%A8%A1%E5%9D%97/"/>
    <id>https://dreamflyingcat.github.io/2018/04/09/中文转拼音模块/</id>
    <published>2018-04-09T02:49:34.957Z</published>
    <updated>2018-04-10T05:32:32.031Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>详情及下载请到<a href="https://github.com/dreamFlyingCat/Chinese2Pinyin" target="_blank" rel="noopener">github</a></p></blockquote><h1 id="中文转拼音或者首字母"><a href="#中文转拼音或者首字母" class="headerlink" title="中文转拼音或者首字母"></a>中文转拼音或者首字母</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>该工具有以下两点功能：</p><ul><li>中文转拼音</li><li>中文转首字母</li></ul><p>可以传入不同的参数控制输出结果。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用npm安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install chinese2pinyin</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre><code>const convert = require(&apos;chinese2pinyin&apos;);// 输出拼音ZhongWenZhuanPinYinHuoShouZiMuconvert({     cn: &apos;中文转拼音或首字母&apos;,    result: &apos;P&apos;})// 输出首字母ZWZPYHSZMconvert({     cn: &apos;中文转拼音或首字母&apos;,    result: &apos;F&apos;})// 输出结果为包含两个key(pinyin和first)的对象convert({     cn: &apos;中文转拼音或首字母&apos;,    result: &apos;A&apos;})/* 使用threshold *///  threshold=5输出ZWZPYHSZM，threshold=9输出ZhongWenZhuanPinYinHuoShouZiMuconvert({     cn: &apos;中文转拼音或首字母&apos;,    result: &apos;P&apos;,    threshold: 5})/* 使用concatKey */// 输出Zhong_Wen_Zhuan_Pin_Yin_Huo_Shou_Zi_Muconvert({    cn: &apos;中文转拼音或首字母&apos;,    result: &apos;P&apos;,    concatKey: &apos;_&apos;})/* 使用remainSpecial */// remainSpecial为true输出ZW-Z-PYH_SZM，否则输出ZWZPYHSZMconvert({    cn: &apos;中文-转-拼音或_首字母&apos;,    result: &apos;F&apos;,    remainSpecial: true})/* 使用double *///double为true输出ZHWZHPYHSHZM，否则输出ZWZPYHSZMconvert({    cn: &apos;中文-转-拼音或_首字母&apos;,    result: &apos;F&apos;,    double: true})</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;详情及下载请到&lt;a href=&quot;https://github.com/dreamFlyingCat/Chinese2Pinyin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
    
      <category term="node.js" scheme="https://dreamflyingcat.github.io/tags/node-js/"/>
    
      <category term="javascript" scheme="https://dreamflyingcat.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>mongoose v5.0.12 中文API - 新手入门</title>
    <link href="https://dreamflyingcat.github.io/2018/04/08/mongoose-%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    <id>https://dreamflyingcat.github.io/2018/04/08/mongoose-新手入门/</id>
    <published>2018-04-08T02:44:02.025Z</published>
    <updated>2018-04-09T05:58:16.674Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>官方原版：<a href="http://mongoosejs.com" target="_blank" rel="noopener">http://mongoosejs.com</a><br>引用请注明出处和转载请注明出处</p></blockquote><h2 id="新手入门"><a href="#新手入门" class="headerlink" title="新手入门"></a>新手入门</h2><p>首先请确定你已经安装了<a href="https://www.mongodb.com/download-center" target="_blank" rel="noopener">mongoDB</a>和<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>。<br>接下来使用<code>npm</code>安装mongoose。</p><pre><code>$ npm install mongoose</code></pre><p>假设我们喜欢毛绒绒的猫咪，想要在mongoDB中记录我们遇见过的每一只猫咪。首先我们要在项目中引入mongoose并且连接到运行在本地MongoDB实例上的<code>test</code>数据库。</p><pre><code>// getting-started.jsvar mongoose = require(&apos;mongoose&apos;);mongoose.connect(&apos;mongodb://localhost/test&apos;);       </code></pre><p>我们需要知道连接到运行在本地的数据库的结果是成功还是失败：</p><pre><code>var db = mongoose.connection;db.on(&apos;error&apos;, console.error.bind(console, &apos;connection error:&apos;));db.once(&apos;open&apos;, function() {// we&apos;re connected!});</code></pre><p>一旦我们发起连接，回调函数会被调用。简洁起见，我们假定下面的代码都写在回调函数中。</p><p>在Mongoose中，所有事物都源于模式。参考下面的代码定义kittens。</p><pre><code>var kittySchema = mongoose.Schema({name: String});</code></pre><p>目前为止，我们创建了一个schema，它只有一个属性——字符串类型的<code>name</code>。下一步要将schema编译为一个<a href="http://mongoosejs.com/docs/models.html" target="_blank" rel="noopener">Model</a>。</p><pre><code>var Kitten = mongoose.model(&apos;Kitten&apos;, kittySchema);</code></pre><p>model是一个class用于构造documents。在这种情况下，每个document都是Kitten的实例，都拥有在schema中声明的属性和行为。让我们创建一个document来代表在路边遇到的一只猫咪。</p><pre><code>var silence = new Kitten({ name: &apos;Silence&apos; });console.log(silence.name); // &apos;Silence&apos;</code></pre><p>猫咪可以喵喵叫，我们学习如何给document添加”speak”功能：</p><pre><code>// NOTE: methods must be added to the schema before compiling it with mongoose.model()kittySchema.methods.speak = function () {    var greeting = this.name        ? &quot;Meow name is &quot; + this.name        : &quot;I don&apos;t have a name&quot;;    console.log(greeting);}var Kitten = mongoose.model(&apos;Kitten&apos;, kittySchema);</code></pre><p>将方法函数添加到schema实例的<code>methods</code>属性上，方法会被编译到<code>Model</code>的原型上从而让每个实例document都可以访问该方法。</p><pre><code>var fluffy = new Kitten({ name: &apos;fluffy&apos; });fluffy.speak(); // &quot;Meow name is fluffy&quot;</code></pre><p>这样猫咪就可以说话啦！到现在我们还没有向mongoDB中保存任何的数据，调用document的<code>save</code>方法保存文档。如果报错，错误对象会包含在回调函数的第一个参数中。</p><pre><code>fluffy.save(function (err, fluffy) {    if (err) return console.error(err);    fluffy.speak();});</code></pre><p>我们可以通过操作Kitten <a href="http://mongoosejs.com/docs/models.html" target="_blank" rel="noopener">Model</a>查看曾经遇到过的所有猫咪的文档。</p><pre><code>Kitten.find(function (err, kittens) {    if (err) return console.error(err);    console.log(kittens);})</code></pre><p>我们将mongoDB中所有的猫咪文档全部打印出来了，我们也可以通过名字过滤猫咪，mongoose支持<a href="https://www.mongodb.com/download-center" target="_blank" rel="noopener">mongoDB</a>丰富的查询语法。</p><pre><code>Kitten.find({ name: /^fluff/ }, callback);</code></pre><p>上例中会查询所有名字以’fluff’开头的猫咪，并将结果放在数组中返回给回调函数。</p><h3 id="Congratulations"><a href="#Congratulations" class="headerlink" title="Congratulations"></a>Congratulations</h3><p>快速入门到此结束。现在我们成功的创建了一个schema并添加了一个自定义的实例方法，使用Mongoose在MongoDB中保存并查询了kittens的文档。进阶学习前往查看<a href="https://github.com/dreamFlyingCat/mongoose-API/blob/master/docs/Schemas/Schema.md" target="_blank" rel="noopener">guide</a>或者<a href="http://mongoosejs.com/docs/api.html" target="_blank" rel="noopener">API文档</a>。</p><h3 id="下一章-——-mongoose指南"><a href="#下一章-——-mongoose指南" class="headerlink" title="下一章 —— mongoose指南"></a>下一章 —— <a href="https://dreamflyingcat.github.io/2018/04/09/mongoose-Schema/">mongoose指南</a></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;官方原版：&lt;a href=&quot;http://mongoosejs.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mongoosejs.com&lt;/a&gt;&lt;br&gt;引用请注明出处和转载请注明出处&lt;/p&gt;
&lt;/block
      
    
    </summary>
    
    
      <category term="mongoose" scheme="https://dreamflyingcat.github.io/tags/mongoose/"/>
    
      <category term="mongoDB" scheme="https://dreamflyingcat.github.io/tags/mongoDB/"/>
    
      <category term="node.js" scheme="https://dreamflyingcat.github.io/tags/node-js/"/>
    
  </entry>
  
</feed>
